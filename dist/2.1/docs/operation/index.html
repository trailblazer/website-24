<!DOCTYPE html>
<html>
  <head>
    <meta content="text/html; charset=UTF-8" http-equiv="Content-Type"/>
    <title>Operation - Trailblazer</title>
    <meta content="width=device-width,initial-scale=1" name="viewport"/>
    
    
    <link rel="stylesheet" href="/assets/tailwind-914b585a1032d1c77ff556e21fa0328e6290facaaf59e55a32c76dff28c9440f.css" />
<link rel="stylesheet" href="/assets/inter-font-8c3e82affb176f4bca9616b838d906343d1251adc8408efe02cf2b1e4fcf2bc4.css" />
    <link rel="stylesheet" href="/assets/application-80c6d4fa2a47744f04139d790060f9790a9daccf2d8e7c23d21488b977633b4d.css" />
    <script>pageIdentifier = "docs";</script>
    <script type="importmap" data-turbo-track="reload">{
  "imports": {
    "application": "/assets/application-a761672f487e42651e347663dab98f5626ca4ebb9cdd0a3460b3e75de647b0ab.js",
    "anchor-js": "/assets/anchor-js-821952d04abcd941bb3541822cd1c1f0234e5168bef1f9b2a050868af608aa5a.js",
    "navigations": "/assets/navigations-27f57ba888008b48256d2635e15bd2f0be7a039b32c8e84140da87596cbf9547.js",
    "highlight.js/lib/core": "/assets/highlight.js--lib--core-d83dc99104442fb344c757a56d28fa888edee01ed7e6dad88a445f7c7ec6d4c9.js",
    "highlight.js/lib/languages/ruby": "/assets/highlight.js--lib--languages--ruby-f74e4cf7cb12132c4f16865b466beac81cd62a84a8119ebf005060b9d5945175.js",
    "jquery": "/assets/jquery-9292661fe0d8c5ef2ef35f5ca64d541d70c87e9f6d7f2716d646591a295b7f36.js",
    "jquery.parallax-scroll": "/assets/jquery.parallax-scroll-a50d2125650d18a234bc9a3eea0a0f1c40871f3ccfba877d0eae70e690955825.js",
    "lottie-player": "/assets/lottie-player-e6cb02cb41d855528f04877264526693c3c897f0264ed3fc91d60fd14ab3529b.js",
    "docsearch": "/assets/docsearch-6a9e3b901da8b6299bb0d2b79e2089a6adf093a79c2cffbfb687b00ea0db3f81.js",
    "docsearch-3.5.2": "/assets/docsearch-3.5.2-3565e3facc916843f7e785300604336389a47920c444394e60c157e2afaa179a.js"
  }
}</script>
<link rel="modulepreload" href="/assets/application-a761672f487e42651e347663dab98f5626ca4ebb9cdd0a3460b3e75de647b0ab.js">
<link rel="modulepreload" href="/assets/anchor-js-821952d04abcd941bb3541822cd1c1f0234e5168bef1f9b2a050868af608aa5a.js">
<script src="/assets/es-module-shims.min-4ca9b3dd5e434131e3bb4b0c1d7dff3bfd4035672a5086deec6f73979a49be73.js" async="async" data-turbo-track="reload"></script>
<script type="module">import "application"</script>
  </head>
  <body>
    <nav class=" text-base z-[50] top-0 absolute w-full lg:h-[5.5rem] lg:px-[5.6rem] py-3 lg:flex lg:justify-between lg:items-center bg-white sticky" id="navbar">
  <a href="/2.1" class="block shrink-0 w-fit mx-auto lg:mx-0">
    <img class="w-40 lg:my-0" src="/assets/logo_blue_ruby-e87334a67ff20033fae8c8d2c07e549b5f1faa9b75bb07fbb2ff9d1c0dfef6e7.svg" />
  </a>
  <div class="lg:hidden absolute right-4 top-2 flex w-9 h-9 items-center" id="hamburgerIcon">
    <div class="pointer-events-none w-full h-0.5 bg-blue transition-all duration-150
                  before:content-[''] before:absolute before:w-full before:h-0.5 before:bg-blue before:-translate-y-2.5 before:transition-all before:duration-150
                  after:content-[''] after:absolute after:w-full after:h-0.5 after:bg-blue after:translate-y-2.5 after:transition-all after:duration-150"></div>
  </div>
  <div class="lg:hidden flex flex-col text-center hidden" id="navList">
    <div class="lg:absolute flex flex-col mt-15 gap-10 uppercase">
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/docs/trailblazer">Documentation</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="https://dev.to/trailblazer">Blog</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/about.html">About</a>
      
      <!-- <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/pro.html">PRO</a> -->
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="https://trailblazer.zulipchat.com">Chat with us</a>
    </div>
  </div>
  <div class="lg:flex hidden gap-10 items-center">
    <div class="flex gap-7">
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold underline decoration-[5px] underline-offset-[15px] decoration-purple hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/docs/trailblazer">Documentation</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="https://dev.to/trailblazer">Blog</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/about.html">About</a>
      <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.0/">→ 2.0</a>
      
      <!-- <a class="font-medium text-base uppercase lg:normal-case lg:font-semibold  hover:underline hover:decoration-[5px] hover:underline-offset-[15px] hover:decoration-purple " href="/2.1/pro.html">PRO</a> -->
    </div>

    <a class="base-button text-base w-[12.5rem] h-[3.25rem] bg-light-purple text-blue hover:text-white hover:bg-purple" href="https://trailblazer.zulipchat.com">Chat with us</a>
  </div>
</nav>

<section>
  <div class="lg:hidden bg-bg-blue text-white fixed left-0 top-20 pr-1 py-3 rounded-r" id="sideNavShowButton" style="writing-mode: vertical-rl; text-orientation: upright;">
    Chapters
  </div>
  <div class="lg:flex">
    <nav class="bg-bg-blue w-screen h-screen fixed top-0 z-20 right-[100vw] overflow-y-scroll lg:w-3/12 lg:max-w-[23rem] lg:overflow-y-visible lg:shrink-0 lg:sticky lg:top-[5.5rem]" id="sideNav">
      <button class="lg:hidden absolute right-4 top-4 text-3xl text-white" id="sideNavHideButton">
        X
      </button>
      <div class="lg:pt-10 lg:pl-5 xl:pl-20 p-10 pl-20 text-white leading-10 space-y-1 h-full overflow-auto">
  


  
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/trailblazer/index.html">Trailblazer</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class="bg-dark-purple flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/operation/index.html">Operation</a>

        

          

            
              <a href="/2.1/docs/activity/deprecated/index.html" class="" title="Deprecated activity docs: :input/:output, ...">
                
                    <svg xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512" class="fill-grey pl-3 hover:fill-purple flex-inline"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M251.7 127.6l0 0c10.5 10.5 24.7 16.4 39.6 16.4H448c8.8 0 16 7.2 16 16v32H48V96c0-8.8 7.2-16 16-16H197.5c4.2 0 8.3 1.7 11.3 4.7l33.9-33.9L208.8 84.7l42.9 42.9zM48 240H464V416c0 8.8-7.2 16-16 16H64c-8.8 0-16-7.2-16-16V240zM285.7 93.7L242.7 50.7c-12-12-28.3-18.7-45.3-18.7H64C28.7 32 0 60.7 0 96V416c0 35.3 28.7 64 64 64H448c35.3 0 64-28.7 64-64V160c0-35.3-28.7-64-64-64H291.3c-2.1 0-4.2-.8-5.7-2.3z"/></svg>
                 
              </a>

            


          

        
      </div>


      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-overview">
          <a href="#operation-overview" class="pl-8">Overview</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-mechanics">
          <a href="#operation-mechanics" class="pl-8">Mechanics</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-step-dsl">
          <a href="#operation-step-dsl" class="pl-8">Step DSL</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-wiring-api">
          <a href="#operation-wiring-api" class="pl-8">Wiring API</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-variable-mapping">
          <a href="#operation-variable-mapping" class="pl-8">Variable Mapping</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-macro-api">
          <a href="#operation-macro-api" class="pl-8">Macro API</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-taskwrap">
          <a href="#operation-taskwrap" class="pl-8">TaskWrap</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-internals">
          <a href="#operation-internals" class="pl-8">Internals</a>
        </div>
      
        
        <!-- FIXME: link should know its IDs. -->
        <div class="flex items-center" id="left-toc-operation-troubleshooting">
          <a href="#operation-troubleshooting" class="pl-8">Troubleshooting</a>
        </div>
      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/rails_integration/index.html">Rails integration</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/test/index.html">Testing</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col border-t-[1px] border-t-light-purple">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/macro/index.html">Macro</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/workflow/index.html">Workflow</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/endpoint/index.html">Endpoint</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/internals/index.html">Internals</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col border-t-[1px] border-t-light-purple">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/reform/index.html">Reform</a>

        

          

            

              <a href="/2.1/docs/reform/3.0/index.html" class="">
                <span class="h-5 text-[8pt] py-[3px] px-2 rounded-[8px] ml-3 hover:bg-purple hover:border-purple hover:text-white border border-grey text-grey">
                  3.0
                </span>
              </a>
            


          

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/cells/index.html">Cells</a>

        

          

            

              <a href="/2.1/docs/cells/5.0/index.html" class="">
                <span class="h-5 text-[8pt] py-[3px] px-2 rounded-[8px] ml-3 hover:bg-purple hover:border-purple hover:text-white border border-grey text-grey">
                  5.0
                </span>
              </a>
            


          

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/representable/index.html">Representable</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/disposable/index.html">Disposable</a>

        
      </div>


      
    </div>

    
  
    <div class="flex flex-col ">
      <div class=" flex items-center">
        <a class="pl-4 font-bold" href="/2.1/docs/roar/index.html">Roar</a>

        
      </div>


      
    </div>

    
  
</div>


    </nav>
    <div class="lg:p-10 pl-8 pr-4 py-10 bg-light-grey grow">
      <h1 class="lg:text-3xl text-2xl text-blue font-bold">
        <span class="py-1 px-3 border border rounded border border-white text-white bg-purple">2.1</span>
        <span class="font-black uppercase header-text">
          Operation
        </span>
        Documentation
      </h1>

      <div class="xl:flex xl:gap-0.5 mt-5">
        <div class="max-w-3xl lg:p-8 lg:pb-14 p-4 bg-white text-bg-blue space-y-9" id="documentation">
          <h2 id="operation-overview" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Overview</span></h2>

<p class="">An operation is the central building block in a Trailblazer architecture. It’s an abstraction that helps structuring your business code while taking over the control flow for you.</p>

<p class="">Operations are often confused as <em>god objects</em> that “do everything”. However, operations are nothing but orchestrators. Where to implement the actual code and when to call it is up to the developer.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">You’re confused about <code class="text-purple">Operation</code> and <code class="text-purple">Activity</code>? It’s simple: an operation is a very thin high-level API around an activity, providing you a less clumsy <code class="text-purple">Operation.call()</code> along with the result object.</p>

<p class="">Both come with the exact same DSL.</p>

  </div>
</div>

<h3 id="operation-overview-step-dsl" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Step DSL</span></h3>

<p class="">Most of the times, operations are defined via our “step DSL”.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">It’s a convenient way for you to define <em>what</em> happens. The operation takes care of the <em>when</em> - which reduces your application code while providing a great amount of beautiful features, such as tracing.</p>

<h3 id="operation-overview-railway" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Railway</span></h3>

<p class="">Internally, the above operation compiles to some kind of “circuit” which looks as follows.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/memo-create-2e6c44caf7b70641b970d74ac05895e5118492bbe67322eab95868819eaff5f2.png" /></p>

<p class="">As visible, your “steps” are placed onto two tracks, forming a “railway”.</p>

<p class="">This is a great concept <a href="https://fsharpforfunandprofit.com/rop/" class="underline text-purple">stolen from functional programming</a>! The railway is your mental model of the code flow. If a step fails, the execution will deviate to the “failure track”, skipping the remaining “success” steps, and eventually stopping on the “failure terminus”. The terminus is how you communicate the outcome of your operation run to the outer world.</p>

<h3 id="operation-overview-invocation" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Invocation</span></h3>

<p class="">Now, that’s why when running your operation, the outcome will always be either “success” or “failure”.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(
  params: {memo: {text: "Do not forget!"}}
)

result.success? # =&gt; true
puts result.terminus.to_h[:semantic] #=&gt; :success
</code></pre>

<p class="">This is how you invoke an operation. Note how the input data goes into the operation’s <code class="text-purple">#call</code> method. It returns the terminus and the <code class="text-purple">ctx</code> object that was passed from step to step within the operation.</p>

<h3 id="operation-overview-step" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Step</span></h3>

<p class="">In an operation your application code is structured into steps. These steps can be any callable Ruby object, but very often, developers use instance methods.</p>

<h4 id="operation-overview-step-signature" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Signature</span>

                  </h4>

<p class="">Check out their signature and the return value!</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    # ...
    def validate(ctx, params:, **) # home-made validation
      params.key?(:memo) &amp;&amp;
      params[:memo].key?(:text) &amp;&amp;
      params[:memo][:text].size &gt; 9
      # return value matters!
    end
  end
end
</code></pre>

<p class="">The hash given into the operation invocation is passed from step to step as <code class="text-purple">ctx</code>. Contained variables, such as <code class="text-purple">:params</code> can be accessed using Ruby’s lovely <a href="https://thoughtbot.com/blog/ruby-2-keyword-arguments" class="underline text-purple">keyword arguments</a> feature.</p>

<p class="">Steps can instruct the operation about the step outcome by returning a truthy or falsey value from the step method.</p>

<h4 id="operation-overview-step-state" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">State</span>

                  </h4>

<p class="">Since we’re dealing with business logic in steps, you’re allowed to write state to the <code class="text-purple">ctx</code> object. The subsequential steps can access the new variables just as any other variable on <code class="text-purple">ctx</code>.</p>

<pre class=""><code class="rounded">def save(ctx, params:, **)
  memo = Memo.new(params[:memo])
  memo.save

  ctx[:model] = memo # you can write to the {ctx}.
end
</code></pre>

<p class="">After running the operation, <code class="text-purple">ctx</code> variables can also be retrieved, for example for rendering in a controller view, or in your unit tests.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(
  params: {memo: {text: "Do not forget!"}}
)

puts result[:model] #=&gt; #&lt;Memo id: 1 text: "Do not forget!"&gt;
</code></pre>

<p class="">And that’s it, you just learnt the basic mechanics of operations.</p>

<h3 id="operation-overview-features" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Features</span></h3>

<p class="">Activities not only help structuring, they are an entirely new development experience that provide a rich and stable API that allows to model almost any business use case.</p>

<h4 id="operation-overview-features-debugging" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Features
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Debugging</span>

                  </h4>

<p class="">Operations can trace themselves when being run. This allows you to see which step had been invoked when, whether or not there was a failure, and so on.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.wtf?(
  # ...
  params: {memo: "remember me!"}
)
</code></pre>

<p class="">Just run the operation using the <code class="text-purple">wtf?</code> method instead of <code class="text-purple">#call</code>.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/cli/memo-create-578020cff912dcbf5de15fa0b5495bccbf1d00fce0d08805721cb93924bc6f32.png" /></p>

<p class="">This will print the trace in the terminal, which is incredibly helpful and time-saving when working with <a href="#operation-wiring-api-subprocess" class="underline text-purple">complex operations</a>.</p>

<p class="">Check out our video on debugging or the <a href="/2.1/docs/trailblazer/#trailblazer-developer" class="underline text-purple">→ DEVELOPER docs</a></p>

<iframe class="mx-auto" width="560" height="315" src="https://www.youtube.com/embed/4udzPXRh1VY?si=nu5lzI0VVnspGgJG" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen=""></iframe>

<h4 id="operation-overview-features-unlimited-wiring" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Features
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Unlimited wiring</span>

                  </h4>

<p class="">In your operation, you can define any circuit you need in order to accomplish your task using the <a href="#operation-wiring-api" class="underline text-purple">Wiring API</a>. You’re not limited to a linear railway!</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-end-c5061e29df5ff0cce91ab1fdb3d1707eb7de8a081eba29a81da831f7f5d129ed.png" /></p>

<p class="">You may add additional termini to your operations to indicate state, go back and retry a particular step, error-out early, or even <a href="#operation-wiring-api-subprocess" class="underline text-purple">nest operations</a> to solve more complex business logic.</p>

<h4 id="operation-overview-features-variable-mapping" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Features
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Variable mapping</span>

                  </h4>

<p class="">For even cleaner code and maximized reusability, you can control what variables come in and out of steps. <a href="/2.1/docs/trailblazer/#operation-variable-mapping" class="underline text-purple">→ VARIABLE MAPPING docs</a></p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message]
    # ...
  end
end
</code></pre>

<p class="">Using our PRO debugger, you can even trace this variable flow.</p>

<h4 id="operation-overview-features-bpmn-and-state-machines" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Features
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">BPMN and state machines</span>

                  </h4>

<p class="">We are (finally, and definitely!) releasing PRO in 2024 which will bring us the <code class="text-purple">workflow</code> gem and our BPMN editor to model and implement complex, long-running workflows.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/bpmn-editor-23-3717812597a8e44907834a4f7ea533e745cb531412830d9f3b1e3b39dca3cabd.png" /></p>

<p class="">This will be pretty exciting and introduces “enterprise” concepts that haven’t been around in Ruby so far.</p>

<h2 id="operation-mechanics" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Mechanics</span></h2>

<p class="">This chapter discusses the fundamental building blocks and concepts of operations: steps, signals, the ctx object and how to run operations.</p>

<h3 id="operation-mechanics-invocation" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Invocation</span></h3>

<p class="">Operations represent functions in your application, both in a domain-oriented way and from a programmatical point of view. That is why there’s only one way to run an operation.</p>

<h4 id="operation-mechanics-invocation-call" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Invocation
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Call</span>

                  </h4>

<p class="">The <code class="text-purple">#call</code> class method is how you run your operation along with its steps.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.call(params: {memo: nil})
</code></pre>

<p class="">And that’s literally the only way to invoke your steps. It is not allowed to run a subset of steps, only. If you need that, you might have to introduce a new operation, or <a href="#operation-wiring-api" class="underline text-purple">change the wiring</a> to achieve the same effect.</p>

<h4 id="operation-mechanics-invocation-implicit-call" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Invocation
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Implicit call</span>

                  </h4>

<p class="">In Ruby, it’s possible to skip the word <code class="text-purple">call</code>. That’s why you might often see invocations of operations that might look a bit cryptic in the beginning.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(params: {memo: nil})
</code></pre>

<p class="">Anyhow, the implicit call style underlines the functional aspect of an operation. Since, per convention, the operation name is a verb (e.g. <code class="text-purple">Create</code>) there’s no need to think of another verb to actually <em>run</em> that “verb”. That’s why we love the implicit call style!</p>

<h4 id="operation-mechanics-invocation-input-variables" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Invocation
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Input variables</span>

                  </h4>

<p class="">Any variables you pass into the invocation will be readable by all steps of the operation (unless configured otherwise).</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(params: {memo: nil})
</code></pre>

<p class="">Here, the <code class="text-purple">:params</code> variable can be accessed in each step via the <code class="text-purple">ctx</code> object, which is the first positional argument passed to each step.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    # ...
    def validate(ctx, **)
      p ctx[:params] #=&gt; {:memo=&gt;nil}
    end
  end
end
</code></pre>

<p class="">While this is a breathtaking feature of Trailblazer, it’s a bit clumsy and we got a more convenient way to read from <code class="text-purple">ctx</code>.</p>

<h4 id="operation-mechanics-invocation-keyword-arguments" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Invocation
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Keyword arguments</span>

                  </h4>

<p class="">Instead of manually checking <code class="text-purple">ctx</code> for the presence of a particular variable, you can add a keyword argument to your step’s signature.</p>

<pre class=""><code class="rounded">def validate(ctx, params:, **)
  p params #=&gt; {:memo=&gt;nil}
end
</code></pre>

<p class="">The <code class="text-purple">:params</code> variable is now a local variable <code class="text-purple">params</code> in your step method.</p>

<p class="">Another benefit: if the caller of your operation fails to provide <code class="text-purple">:params</code>, Ruby will complain automatically of a missing keyword!</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(current_user: user)
#=&gt; ArgumentError: missing keyword: :params
#       memo/operation/create.rb:9:in `validate'
</code></pre>

<p class="">Ruby’s epic <a href="https://thoughtbot.com/blog/ruby-2-keyword-arguments" class="underline text-purple">keyword arguments</a> even allow defaulting of variables, should they be absent in <code class="text-purple">ctx</code>.</p>

<p class="">Note that you can use any number of keyword arguments in your signature.</p>

<h4 id="operation-mechanics-invocation-writing-state" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Invocation
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Writing state</span>

                  </h4>

<p class="">It is also possible to <em>write</em> to <code class="text-purple">ctx</code>, should you fancy to publish information out of the step.</p>

<pre class=""><code class="rounded">def save(ctx, params:, **)
  ctx[:model] = Memo.new(params[:memo])
end
</code></pre>

<p class="">The following steps will be able to read the <code class="text-purple">:model</code> variable exactly the same way it worked with <code class="text-purple">:params</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save # sets ctx[:model]
    step :notify
    # ...
    def notify(ctx, model:, **)
      send_email(model)
    end
  end
end
</code></pre>

<p class="">Once an operation run finished, variables added to the <code class="text-purple">ctx</code> are readable by the caller on the outside via the <a href="#operation-mechanics-result" class="underline text-purple">result object</a>.</p>

<p class="">Keep in mind that the above is the default behavior. You may configure what comes in and goes out of a step using <a href="#operation-variable-mapping" class="underline text-purple">variable mapping</a>.</p>

<h3 id="operation-mechanics-flow-control" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Flow control</span></h3>

<p class="">When being invoked with <code class="text-purple">#call</code>, the operation works off its steps in the order they were defined with <code class="text-purple">#step</code>. This is called the “happy path”, or the success track.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/memo-create-2e6c44caf7b70641b970d74ac05895e5118492bbe67322eab95868819eaff5f2.png" /></p>

<p class="">Once a step returns a “failure”, the operation will deviate to the “failure track” and skip the remaining steps on the success track. Instead, the remaining steps added using <code class="text-purple">#left</code> (formerly <code class="text-purple">#fail</code>) will be executed.</p>

<p class="">Steps can communicate their outcome to the operation’s flow control with their return value.</p>

<h4 id="operation-mechanics-flow-control-success" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Flow control
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Success</span>

                  </h4>

<p class="">The <code class="text-purple">#validate</code> step in our example does a simple check to see if <code class="text-purple">params[:memo]</code> is present.</p>

<pre class=""><code class="rounded">def validate(ctx, params:, **)
  params.key?(:memo) # =&gt; true/false
end
</code></pre>

<p class="">Since this is the only line in the method, the return value will be either true, signalizing a successful validation, or false, indicating there’s a formal problem with the incoming user data.</p>

<p class="">The return value doesn’t have to <code class="text-purple">true</code> or <code class="text-purple">false</code>, but can be any “truthy” or “falsey” (e.g. <code class="text-purple">nil</code>) value.</p>

<h4 id="operation-mechanics-flow-control-failure" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Flow control
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Failure</span>

                  </h4>

<p class="">A falsey return value will deviate the operation’s path to the failure track.</p>

<pre class=""><code class="rounded">def validate(ctx, params:, **)
  nil
end
</code></pre>

<p class="">This depressive step will always return a falsey value (<code class="text-purple">nil</code> is evaluated to <code class="text-purple">false</code>), the remaining success path steps will always be skipped. Don’t do this!</p>

<h4 id="operation-mechanics-flow-control-signal" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Flow control
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Signal</span>

                  </h4>

<p class="">The binary <code class="text-purple">true</code>/<code class="text-purple">false</code> outcome is useful for many scenarios. However, sometimes a step might have a third outcome - for example, to indicate a network error that needs to be handled off the failure track.</p>

<pre class=""><code class="rounded">def notify(ctx, model:, params:, **)
  return NetworkError unless check_network(params)

  send_email(model)
end
</code></pre>

<p class="">In this step, we’re returning a “third” possible value. The trick is: the <code class="text-purple">NetworkError</code> needs to be a subclass of <code class="text-purple">Signal</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    class NetworkError &lt; Trailblazer::Activity::Signal
    end
    # ...
  end
end
</code></pre>

<p class="">That way, the operation’s routing will recognize this third outcome. Speaking of, the third scenario needs to be properly connected using the <a href="#operation-wiring-api" class="underline text-purple">Wiring API</a>.</p>

<pre class=""><code class="rounded">step :validate
step :save
left :handle_errors
step :notify,
  Output(NetworkError, :network_error) =&gt; End(:network_error)
</code></pre>

<p class="">Using tools the Wiring API provides, this adds new connections plus an entire new terminus of our operation!</p>

<h3 id="operation-mechanics-terminus" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Terminus</span></h3>

<p class="">Here, <code class="text-purple">#notify</code> encountering a disastrous network error will make the operation stop the execution in a third terminus called <code class="text-purple">network_error</code>.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/memo-network-error-f6a980ec98907a45c03bd3b3ddb1fddb4753cc61332d58a5a1bca7e34204575d.png" /></p>

<h4 id="operation-mechanics-terminus-semantic" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Terminus
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Semantic</span>

                  </h4>

<p class="">In general, a terminus is a way to communicate an outcome state of a particular operation to the user. This can be as simple as manually running an operation and checking which terminus it stopped in.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(params: {memo: nil, network_broken: true})

result.terminus.to_h[:semantic] #=&gt; :network_error
</code></pre>

<p class="">You can ask the terminus for its <em>semantic</em> by calling <code class="text-purple">#to_h</code>. The semantic can be any meaningful term you want, for instance, we named the success path terminus <code class="text-purple">:success</code>.</p>

<h4 id="operation-mechanics-terminus-nesting" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Terminus
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Nesting</span>

                  </h4>

<p class="">Those termini start making even more sense when nesting operations.</p>

<pre class=""><code class="rounded">module Endpoint
  class API &lt; Trailblazer::Operation
    step Subprocess(Memo::Operation::Create),
      Output(:network_error) =&gt; Track(:failure)
    # ...
  end
end
</code></pre>

<p class="">It is possible (and required!) to wire termini of a nested operation into the container circuit - this is much cleaner than handling different outcomes by hand, and allows for tracing and debugging.</p>

<p class="">Check out the <a href="#operation-wiring-api" class="underline text-purple">Wiring API</a> to learn how to leverage multiple outcomes in operations.</p>

<h3 id="operation-mechanics-result" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Result</span></h3>

<p class="">As the <code class="text-purple">ctx</code> is being passed from step to step, it accumulates data. In order to access this data on the outside, the <code class="text-purple">ctx</code> is converted to a result object after the run is finished.</p>

<p class="">You can read variables using the <code class="text-purple">#[]</code> reader.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(params: {memo: {content: "remember that"}})

result[:model] #=&gt; #&lt;Memo id: 1, ...&gt;
</code></pre>

<p class="">In addition to the ctx variables, the result object also exposes the outcome of the entire operation run.</p>

<pre class=""><code class="rounded">puts result.success? #=&gt; true
</code></pre>

<p class="">For your convenience, the result object also exposes <code class="text-purple">#failure?</code> as a counter-part.</p>

<h3 id="operation-mechanics-inheritance" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Inheritance</span></h3>

<p class="">Operations are classes that provide a DSL to model the logic circuit.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step :validate
    step :save
    # ...
  end
end
</code></pre>

<p class="">You can use Ruby’s inheritance to derive subclasses from operations.</p>

<h4 id="operation-mechanics-inheritance-subclass" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Inheritance
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Subclass</span>

                  </h4>

<p class="">Inheritance allows you to share logic and behavior across any number of subclasses.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Update &lt; Create
  end
end
</code></pre>

<p class="">Subclassing will not only copy over methods, but the entire circuit of <code class="text-purple">Create</code> along with its three steps.</p>

<h4 id="operation-mechanics-inheritance-customize" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Inheritance
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Customize</span>

                  </h4>

<p class="">You can now insert, replace or even delete new steps in the <code class="text-purple">Update</code> class.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Update &lt; Create
    step :find_model, replace: :create_model
    # ...
  end
end
</code></pre>

<p class="">This will replace the <code class="text-purple">create_model</code> step with new <code class="text-purple">find_model</code> logic. Obviously, you have to provide the <code class="text-purple">#find_model</code> method in the <code class="text-purple">Update</code> class.</p>

<p class="">When inserting steps into subclasses you can use any <a href="#operation-step-dsl-sequence-options" class="underline text-purple">step DSL options</a>. You might even drill into deeply nested, inherited class compounds <a href="#FIXME" class="underline text-purple">using <code class="text-purple">#patch</code></a>.</p>

<h2 id="operation-step-dsl" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Step DSL</span><span class="flex max-w-fit max-h-7 border border-grey uppercase text-grey text-xs pt-1 pb-1 pl-2 pr-2 pr-1 ml-4 rounded">
            <svg class="fill-grey mt-[2px]" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M168.5 72L256 165l87.5-93h-175zM383.9 99.1L311.5 176h129L383.9 99.1zm50 124.9H256 78.1L256 420.3 433.9 224zM71.5 176h129L128.1 99.1 71.5 176zm434.3 40.1l-232 256c-4.5 5-11 7.9-17.8 7.9s-13.2-2.9-17.8-7.9l-232-256c-7.7-8.5-8.3-21.2-1.5-30.4l112-152c4.5-6.1 11.7-9.8 19.3-9.8H376c7.6 0 14.8 3.6 19.3 9.8l112 152c6.8 9.2 6.1 21.9-1.5 30.4z" /></svg>
            <a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear/tree/v1.2.2" class="ml-1" title="This feature was introduced in trailblazer-activity-dsl-linear v1.2.2.">dsl 1.2.2</a>
          </span></h2>

<p class="">When writing operations, most of the time you will use <code class="text-purple">#step</code> and <code class="text-purple">#left</code> to configure your activity’s circuit. While it is possible to model any kind of flow, the operation’s “Step DSL” is optimized for building a railway layout.</p>

<h3 id="operation-step-dsl-railway" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Railway</span></h3>

<p class="">In operations, the <a href="http://fsharpforfunandprofit.com/rop/" class="underline text-purple"><code class="text-purple">Railway</code> layout</a> is used to build circuits with “automatic” error handling. You arrange your actual chain of logic on the “success” track, if a problem occurs, the processing jumps to the parallel “failure” track, skipping the rest of the tasks on the success track.</p>

<p class="">Once on the failure track, it stays there (unless you instruct not to do so!).</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">This operation will look as follows.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/memo-create-2e6c44caf7b70641b970d74ac05895e5118492bbe67322eab95868819eaff5f2.png" /></p>

<p class="">Four possible execution paths this operation might take.</p>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">No errors: First <code class="text-purple">validate</code>, then <code class="text-purple">save</code>, then <code class="text-purple">notify</code>, then terminate in <code class="text-purple">End.success</code>. The operation was successful.</li>
  <li class="list-image-disc ml-10">Validation error: First <code class="text-purple">validate</code>, which returns a <code class="text-purple">Left</code> (failure) signal, leading to <code class="text-purple">handle_errors</code>, then terminate in <code class="text-purple">End.failure</code>.</li>
  <li class="list-image-disc ml-10">DB error: First <code class="text-purple">validate</code>, then <code class="text-purple">save</code>, which deviates to the failure track, leading to <code class="text-purple">End.failure</code>.</li>
  <li class="list-image-disc ml-10">Notify error: <code class="text-purple">validate</code>, <code class="text-purple">save</code>, then <code class="text-purple">notify</code> fails, terminating in <code class="text-purple">End.failure</code>. Note that this doesn’t hit the error handler due to the sequence order.</li>
</ul>

<h4 id="operation-step-dsl-railway-step" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Railway
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Step</span>

                  </h4>

<p class="">For placing a step onto the success track, use <code class="text-purple">#step</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save
    # ...
</code></pre>

<p class="">This simply puts one step after another, in the order you define, on the success track.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Note that it’s possible to insert steps by using inheritance or modules. # FIXME</p>

  </div>
</div>

<p class="">Without any options, the step’s interface is expected to follow the “step interface”. # FIXME</p>

<h4 id="operation-step-dsl-railway-left" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Railway
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Left</span>

                  </h4>

<p class="">To place tasks on the failure track, use <code class="text-purple">#left</code>. Again, the order and position defines where this particular step will sit on the failure track.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save
    left :handle_errors
    # ...
</code></pre>

<p class="">Obviously, you may use as many tasks as you need on this track - there are no limitations.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Historically, the success path is called “right” whereas the error handling track is “left”. The signals <code class="text-purple">Right</code> and <code class="text-purple">Left</code> in Trailblazer are still named following this convention.</p>

  </div>
</div>

<h4 id="operation-step-dsl-railway-fail" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Railway
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Fail</span>

                  </h4>

<p class="">Before we introduced <code class="text-purple">#left</code>, the DSL method to place steps onto the failure track was named <code class="text-purple">#fail</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save
    fail :handle_errors # just like {#left}
    # ...
  end
end
</code></pre>

<p class="">Both methods are identical. It is not deprecated, feel free to use it instead of <code class="text-purple">#left,</code> should your editor allow it.</p>

<h4 id="operation-step-dsl-railway-pass" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Railway
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Pass</span>

                  </h4>

<p class="">If the return value of a task on the success path shouldn’t matter, use <code class="text-purple">#pass</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    pass :save # no output goes to the failure track here.
    left :handle_errors
    # ...
  end
end
</code></pre>

<p class=""><code class="text-purple">#save</code>’s return value is ignored in the operation run, the next step will always be <code class="text-purple">#notify</code> on the success track.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/memo-pass-cd2caa152810cfe42510829082e199de646c7be04afc065eec648fe65b294cc5.png" /></p>


<h3 id="operation-step-dsl-step" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Step</span></h3>

<p class="">An operation can be composed of any number of steps. Steps can be callable Ruby objects or instance methods of the operation itself.</p>

<p class="">When adding a step using <code class="text-purple">#step</code> or <code class="text-purple">#left</code>, the step’s interface is considered to be exposing the “step interface”. Note that you can also implement steps with a <a href="#operation-internals-circuit-interface" class="underline text-purple">low-level interface</a> called the “circuit interface” that is clumsier but also richer.</p>

<h4 id="operation-step-dsl-step-instance-method" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Instance method</span>

                  </h4>

<p class="">A step declared with a <code class="text-purple">:symbol</code>, as done here with <code class="text-purple">#validate</code>, will be considered an instance method of the operation class. This style allows to define the operation layout before implementing the steps in the same class.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate

    def validate(ctx, params:, **)
      params.key?(:memo) ? true : false # return value matters!
    end
  end
end
</code></pre>

<p class="">Signature and return value are identical to all other step types.</p>

<h4 id="operation-step-dsl-step-class-method" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Class method</span>

                  </h4>

<p class="">A class method can come in handy if you want to reuse this particular step in an entirely different operation.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    # Define {Memo::Operation::Create.validate}
    def self.validate(ctx, params:, **)
      params.key?(:memo) ? true : false # return value matters!
    end

    step method(:validate)
  end
end
</code></pre>

<p class="">Note that the actual class method has to be defined before retrieving the method object via <code class="text-purple">method(:validate)</code>. Again, signature and return value are identical to other styles.</p>

<h4 id="operation-step-dsl-step-module-method" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Module method</span>

                  </h4>

<p class="">Just like a class method, steps can come from any module - this makes it straight-forward to create reusable chunks of logic.</p>

<pre class=""><code class="rounded"># Reusable steps in a module.
module Steps
  def self.validate(ctx, params:, **)
    params.key?(:memo) ? true : false # return value matters!
  end
end
</code></pre>

<p class="">The mechanics to use a “foreign” method as a step are identical to using a class method - they simply rely on <a href="https://ruby-doc.org/3.2.2/Method.html" class="underline text-purple">Ruby’s <code class="text-purple">#method</code> function</a>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step Steps.method(:validate)
  end
end
</code></pre>

<p class="">This is a common technique in complex Trailblazer applications for creating reusable steps with a high degree of maintainability.</p>

<h4 id="operation-step-dsl-step-callable" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Callable</span>

                  </h4>

<p class="">As a matter of fact, any object, module or class exposing a <code class="text-purple">#call</code> method can be a step!</p>

<pre class=""><code class="rounded">module Validate
  def self.call(ctx, params:, **)
    valid?(params) ? true : false # return value matters!
  end

  def valid?(params)
    params.key?(:memo)
  end
end
</code></pre>

<p class="">Callable objects are often used when the step’s logic exceeds a certain threshold of complexity and you want to introduce additional methods, as the above <code class="text-purple">#valid?</code> function.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Keep in mind that a step can also be implemented using a second <em>operation</em>. You can use the <a href="#operation-wiring-api-subprocess" class="underline text-purple"><code class="text-purple">Subprocess()</code> macro</a> to nest operations.</p>

  </div>
</div>

<h4 id="operation-step-dsl-step-lambda" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Lambda</span>

                  </h4>

<p class="">Another trick, mostly used for debugging, is to use a lambda as a step.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step -&gt;(ctx, params:, **) { p params.inspect }
  end
end
</code></pre>

<p class="">Obviously, this is not really sustainable and should be replaced with one of the above options.</p>

<h3 id="operation-step-dsl-sequence-options" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Sequence Options</span></h3>

<p class="">In addition to wiring options, there are a handful of other options known as <em>sequence options</em>. They configure where a task goes when inserted, and helps with introspection and tracing.</p>

<h4 id="operation-step-dsl-sequence-options-id" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Sequence Options
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">id</span>

                  </h4>

<p class="">The DSL will provide default names for tasks.
You can name explicitely using the <code class="text-purple">:id</code> option.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save, id: :save_the_world
    step :notify
    # ...
  end
end
</code></pre>

<p class="">The IDs are as follows.</p>

<pre class=""><code class="rounded">Trailblazer::Developer.railway(Memo::Operation::Create)
#=&gt; [&gt;validate,&gt;save_the_world,&gt;notify]
</code></pre>

<p class="">Assigning explicit IDs to steps is advisable when you’re planning use patching or inheritance. Keep in mind that this ID will be part of your internal (but public) API.</p>

<p class="">Naming also shows up in tracing and introspection.</p>

<p class="">If no <code class="text-purple">:id</code> is provided, defaults names are given to steps - these might be awkward sometimes.</p>

<h4 id="operation-step-dsl-sequence-options-delete" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Sequence Options
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Delete</span>

                  </h4>

<p class="">When it’s necessary to remove a task, you can use <code class="text-purple">:delete</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Admin &lt; Create
    step nil, delete: :validate
  end
end
</code></pre>

<p class="">The <code class="text-purple">:delete</code> option can be helpful when using modules or inheritance to build concrete operations from base operations. In this example, a very poor one, the <code class="text-purple">validate</code> task gets removed, assuming the <code class="text-purple">Admin</code> won’t need a validation.</p>

<pre class=""><code class="rounded">Trailblazer::Developer.railway(Memo::Operation::Admin)
#=&gt; [&gt;save_the_world,&gt;notify]
</code></pre>

<p class="">All steps are inherited, then the deletion is applied, as the introspection shows.</p>

<h4 id="operation-step-dsl-sequence-options-before" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Sequence Options
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Before</span>

                  </h4>

<p class="">To insert a new task before an existing one, for example in a subclass, use <code class="text-purple">:before</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Authorized &lt; Memo::Operation::Create
    step :policy, before: :validate
    # ...
  end
end
</code></pre>

<p class="">The activity now contains a new <code class="text-purple">policy</code> step just before the inherited tasks.</p>

<pre class=""><code class="rounded">Trailblazer::Developer.railway(Memo::Operation::Authorized)
#=&gt; [&gt;policy,&gt;validate,&gt;save_the_world,&gt;notify]
</code></pre>

<h4 id="operation-step-dsl-sequence-options-after" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Sequence Options
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">After</span>

                  </h4>

<p class="">To insert after an existing task, you might have guessed it, use the <code class="text-purple">:after</code> option with the exact same semantics as <code class="text-purple">:before</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Authorized &lt; Memo::Operation::Create
    step :policy, after: :validate
    # ...
  end
end
</code></pre>

<p class="">The task is inserted after, as the introspection shows.</p>

<pre class=""><code class="rounded">Trailblazer::Developer.railway(Memo::Operation::Authorized)
#=&gt; [&gt;validate,&gt;policy,&gt;save_the_world,&gt;notify]
</code></pre>

<h4 id="operation-step-dsl-sequence-options-replace" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Sequence Options
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Replace</span>

                  </h4>

<p class="">Replacing an existing task is done using <code class="text-purple">:replace</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Update &lt; Create
    step :update, replace: :save
    # ...
  end

end
</code></pre>

<p class="">Replacing, obviously, only replaces in the applied class, not in the superclass.</p>

<pre class=""><code class="rounded">Trailblazer::Developer.railway(Memo::Operation::Update)
#=&gt; [&gt;validate,&gt;update,&gt;notify]
</code></pre>

<h4 id="operation-step-dsl-sequence-options-inherit" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Sequence Options
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Inherit</span>

                  </h4>


<h3 id="operation-step-dsl-patching" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Patching</span></h3>

<p class="">Working with <code class="text-purple">Subprocess</code> and nested activities is a great way to encapsulate and create reusable code especially with complex logic. However, it can be a PITA if you want to customize one of those deeply nested components and add, replace or remove a certain step.</p>

<p class="">Suppose the following 3-level nested activity.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" width="63%" src="/assets/patch-bcd7630136eb2d8e2fd342cc94be1deb81b17f6313e448548ffd0493425fce74.png" /></p>

<p class="">The public operation <code class="text-purple">Destroy</code> contains <code class="text-purple">Delete</code> as a nested activity, which itself contains <code class="text-purple">DeleteAssets</code>. In order to customize the latter one and add another step <code class="text-purple">tidy_storage</code>, you’d normally have to subclass all three activities and override steps.</p>

<h4 id="operation-step-dsl-patching-patch" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Patching
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Patch</span>

                  </h4>

<p class="">Using <code class="text-purple">#patch</code>, you can modify nested activities from the uppermost activity and let Trailblazer do the legwork.</p>

<p class="">As <code class="text-purple">#patch</code> is mostly used when leveraging inheritance we introduce a subclass of <code class="text-purple">Destroy</code> which is called <code class="text-purple">Erase</code> and introduces the <code class="text-purple">#tidy_storage</code> step. As illustrated above, this new step should be inserted in <code class="text-purple">DeleteAssets</code> activity that itself is nested in <code class="text-purple">Delete</code>, which again is one step of <code class="text-purple">Destroy</code>.</p>

<pre class=""><code class="rounded">class Erase &lt; Destroy # we're inheriting from Song::Operation::Destroy
  # ...
  def self.tidy_storage(ctx, **)
    # delete files from your amazing cloud
  end
  # ...
  # These steps are inherited:
  # step :policy
  # step :find_model
  # step Subprocess(Delete), id: :delete

  extend Trailblazer::Activity::DSL::Linear::Patch::DSL

  # Note the path you pass to #patch.
  patch(:delete, :delete_assets) {
    step Erase.method(:tidy_storage), after: :rm_images
  }
end
</code></pre>

<p class="">The patching logic accepts a path to the particular activity that you want to modify.</p>

<pre class=""><code class="rounded">
patch(:delete, :delete_assets) { ... }</code></pre>

<p class="">The provided block is executed within that targeted activity and executed as if you’d extend that class. However, the entire modification will only change <code class="text-purple">Erase</code>, all other traversed activities are copied and then modified, leaving the original implemenation unchanged.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/patch-trace-9c20114ea59171f3d46345361ee0ea9522a621429f22f9f64a7723c5937158b2.png" /></p>

<p class="">The <code class="text-purple">#patch</code> method is perfect when using inheritance to first copy over behavior and control flow, and then fine-tune it for the specific use case.</p>

<h4 id="operation-step-dsl-patching-patch-option" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Patching
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Patch Option</span>

                  </h4>

<p class="">If you’re not using inheritance and want to tweak a nested activity ad-hoc the <code class="text-purple">Subprocess()</code> helper accepts a <code class="text-purple">:patch</code> option.</p>

<div class="spacing-y-0"><div class="spacing-x-1 mb-[6px]">
            <a href="#" data-toggle="code-tab" data-type="code-tab-activity">
              <span class="font-semi-bold bg-bg-purple-1 p-2 rounded-t" data-show="code-tab-activity" data-hide="code-tab-operation" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Activity</span>
            </a>
            <a href="#" data-toggle="code-tab" data-type="code-tab-operation">
              <span class="font-semi-bold bg-[#E4E4E4] p-2 rounded-t" data-show="code-tab-operation" data-hide="code-tab-activity" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Operation</span>
            </a>
          </div><div class="code-tab-activity code-tab-content"><pre class=""><code class="rounded-tr rounded-b">class Destroy &lt; Trailblazer::Activity::Railway
  def self.tidy_storage(ctx, **)
    # delete files from your amazing cloud
    true
  end
  # ...
  step :policy
  step :find_model
  step Subprocess(Delete,
    patch: {
      [:delete_assets] =&gt; -&gt; { step Destroy.method(:tidy_storage), before: :rm_uploads }
    }
  )
end
</code></pre></div><div class="code-tab-operation code-tab-content hidden"><pre class=""><code class="rounded-tr rounded-b">class Destroy &lt; Trailblazer::Operation
  def self.tidy_storage(ctx, **)
    # delete files from your amazing cloud
    true
  end
  # ...
  step :policy
  step :find_model
  step Subprocess(Delete,
    patch: {
      [:delete_assets] =&gt; -&gt; { step Destroy.method(:tidy_storage), before: :rm_uploads }
    }
  )
end
</code></pre></div></div>

<p class="">This works just like the <code class="text-purple">#patch</code> function but returns the patched activity.</p>

<p class=""><code class="text-purple">Subprocess()</code> accepts the <code class="text-purple">:patch</code> option which consists of a hash of the path to the customized activity, and its patch.</p>

<p class="">This will result in an identical operation as in the above example with <code class="text-purple">#patch</code>. However, <code class="text-purple">Delete</code> is now the operation containing the customization, not a new class <code class="text-purple">Erase</code>.</p>

<p class="">Patching can be also done at the top-level activity by passing  <code class="text-purple">:patch</code> as a block (Take <code class="text-purple">Delete</code> from above example).</p>

<pre class=""><code class="rounded">step Subprocess(
  Delete,
  patch: -&gt; { step Destroy.method(:tidy_storage), before: :delete_model }
), id: :delete
</code></pre>


<h2 id="operation-wiring-api" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Wiring API</span></h2>

<p class="">You can use the wiring API to model more complicated circuits in operations.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Since the wiring API is part of the Step DSL, it’s implemented in the <a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear" class="underline text-purple"><code class="text-purple">trailblazer-activity-dsl-linear</code> gem</a>. Feel invited to extend our DSL!</p>

  </div>
</div>

<h3 id="operation-wiring-api-railway" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Railway</span></h3>

<p class="">Without additional configuration, when using <code class="text-purple">#step</code> the following happens.</p>

<ol>
  <li class="list-image-disc ml-10">The new step is put either on the success or failure track, depending on whether you used <code class="text-purple">#step</code> or <a href="#operation-step-dsl-railway-left" class="underline text-purple"><code class="text-purple">#left</code></a> for insertion (internally, this happens via the <code class="text-purple">:magnetic_to</code> option).</li>
  <li class="list-image-disc ml-10">The respective predecessor step is connected to the new step.</li>
  <li class="list-image-disc ml-10">As, in a railway, a step typically has two logical outcomes, the step’s <code class="text-purple">success</code> output is connected to the following step on the success track. Usually, this would be the <code class="text-purple">success</code> terminus.</li>
  <li class="list-image-disc ml-10">The exact same thing happens for the step’s <code class="text-purple">failure</code> output.</li>
</ol>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/memo-create-2e6c44caf7b70641b970d74ac05895e5118492bbe67322eab95868819eaff5f2.png" /></p>

<p class="">Looking closer at a step, the orange circle on a step’s edge represents the <code class="text-purple">failure</code> output. The outgoing line without any circle is the <code class="text-purple">success</code> output.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Technically, this diagram is incorrect since steps sitting on the <code class="text-purple">failure</code> track have two outputs as well. However, as both outputs are linked to the next failure step, this is usually depicted as a single line.</p>

  </div>
</div>

<p class="">Now, let’s see how we can customize this operation using the Wiring API.</p>

<h4 id="operation-wiring-api-railway-debugging" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Railway
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Debugging</span>

                  </h4>

<p class="">When modeling more complex circuits and becoming familiar with the Wiring API, do not get frustrated! Use our <code class="text-purple">trailblazer-developer</code> gem to quickly visualize what you’ve just built.</p>

<pre class=""><code class="rounded">puts Trailblazer::Developer.render(Memo::Operation::Create)

#&lt;Start/:default&gt;
 {Trailblazer::Operation::Right} =&gt; #&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=validate&gt;
#&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=validate&gt;
 {Trailblazer::Operation::Left} =&gt; #&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=handle_errors&gt;
 {Trailblazer::Operation::Right} =&gt; #&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=save&gt;
#&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=save&gt;
 {Trailblazer::Operation::Left} =&gt; #&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=handle_errors&gt;
 {Trailblazer::Operation::Right} =&gt; #&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=notify&gt;
#&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=handle_errors&gt;
 {Trailblazer::Operation::Left} =&gt; #&lt;End/:failure&gt;
 {Trailblazer::Operation::Right} =&gt; #&lt;End/:failure&gt;
#&lt;Trailblazer::Operation::TaskBuilder::Task user_proc=notify&gt;
 {Trailblazer::Operation::Left} =&gt; #&lt;End/:failure&gt;
 {Trailblazer::Operation::Right} =&gt; #&lt;End/:success&gt;
#&lt;End/:success&gt;

#&lt;End/:failure&gt;
</code></pre>

<p class="">The <code class="text-purple">render</code> method returns the actual circuit in a more or less human-readable form.</p>

<h3 id="operation-wiring-api-output-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Output()</span></h3>

<p class="">Rewiring a particular step always starts with <code class="text-purple">Output()</code>. This DSL helper allows you to specify which <em>outgoing</em> connection you’re planning to reconnect.</p>

<h4 id="operation-wiring-api-output-implicit-output" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Output()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Implicit output</span>

                  </h4>

<p class="">In a railway-based activity, such as <code class="text-purple">Trailblazer::Operation</code>, each step exposes two outputs per default: <code class="text-purple">:success</code> and <code class="text-purple">:failure</code>. This is why you can simply reference that well-known output by its semantic. The one-argument form of <code class="text-purple">Output()</code> we call “implicit output”.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save,
      Output(:failure) =&gt; Track(:success)
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">With this customization, you’re building a bullet-proof <code class="text-purple">#save</code> step, that even in case of failure goes back to the success track. Hopefully, your <code class="text-purple">#save</code> logic is failsafe.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-output-47dd59642622911adf8e700211be1cd7510f9371ec219d91e72168038d8bcf25.png" /></p>

<p class="">This, by the way, is how <code class="text-purple">#pass</code> is implemented.</p>

<h4 id="operation-wiring-api-output-explicit-output" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Output()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Explicit output</span>

                  </h4>

<p class="">If needed, a step can have more than two outcomes. For instance, <code class="text-purple">#save</code> could detect and report a database error in addition to its binary outcomes of success and failure.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    class DbError &lt; Trailblazer::Activity::Signal; end

    step :validate
    step :save,
      Output(DbError, :database_error) =&gt; Track(:failure)
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">To add an output, you call <code class="text-purple">Output()</code> with two arguments: the signal to indicate, and the semantic of that new output. Note that the signal has to be derived from <code class="text-purple">Trailblazer::Activity::Signal</code>.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-explicit-output-fac49ac3e6ae87d4cd74c24c6aa4a61d4b8ab39d446ea743ef4c72f38c379633.png" /></p>

<p class="">In this example, the new output <code class="text-purple">:database_error</code> is routed straight to the failure track. When the operation teminates, you might not be able to see why it failed: it might be better to introduce a separate terminus.</p>

<h4 id="operation-wiring-api-output-failure" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Output()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Failure</span>

                  </h4>

<p class="">It might be worth noting that all steps in a railway have two standard outputs, even those put on the <code class="text-purple">failure</code> track using <code class="text-purple">#left</code>! That’s why you don’t have to stay on the failure track, you could divert anywhere you want.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save
    left :handle_errors,
      Output(:success) =&gt; Track(:success)
    step :notify
    include T.def_steps(:validate, :save, :handle_errors, :notify)
  end
end
</code></pre>

<p class="">If the <code class="text-purple">#handle_errors</code> step returns a truthy value, the operation goes back to the success track.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-left-64b03cef330aebf4aed55c009b1469bc2288f6997942244b01581a21a3fccdd8.png" /></p>

<p class="">This pattern can be used for error handling, deciders, or alternate routes.</p>

<h3 id="operation-wiring-api-end-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">End()</span></h3>

<p class="">A terminus represents an outcome of an operation run. It’s not only helpful when running an operation manually, but also when nesting operations.</p>

<p class="">You can use the <code class="text-purple">End()</code> helper to connect an output directly to either an existing terminus (most of the times, that’d be <code class="text-purple">:success</code> or <code class="text-purple">:failure</code>), or you can wire it to a new terminus.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save,
      Output(:failure) =&gt; End(:db_error)
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">Two things happen here: first, the new terminus <code class="text-purple">:db_error</code> is added to the operation as it represents an unknown, new terminus. Then, the <code class="text-purple">failure</code> output of <code class="text-purple">#save</code> gets connected to it.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-end-c5061e29df5ff0cce91ab1fdb3d1707eb7de8a081eba29a81da831f7f5d129ed.png" /></p>

<p class="">You may use <code class="text-purple">End()</code> multiple times in one operation. This will connect the steps to the same terminus.</p>

<h3 id="operation-wiring-api-terminus" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Terminus</span></h3>

<p class="">Instead of <code class="text-purple">End()</code> you may add additional termini to an operation using <code class="text-purple">#terminus</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class CRUD &lt; Trailblazer::Operation
    step :validate
    step :save
    terminus :db_error
    # ...
  end
end
</code></pre>

<p class="">The <code class="text-purple">CRUD</code> class here acts as an abstract template for concrete operations.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-terminus-df768e4c773f0dce0b6e8b22839a8ac7374e71e9cc19503cbe01851824532e0e.png" /></p>

<p class="">In a subclass, you could then connect steps to this new terminus using <code class="text-purple">End()</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; CRUD
    step :notify,
      Output(:failure) =&gt; End(:db_error)
    # ...
  end
end
</code></pre>

<p class="">Note that there are more inheritance mechanics for building template operations, such as the <a href="#operation-mechanics-inheritance" class="underline text-purple"><code class="text-purple">:inherit</code> option</a>.</p>

<h3 id="operation-wiring-api-track-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Track()</span></h3>

<p class="">Use <code class="text-purple">Track()</code> when you want a step’s output to connect to the next
step that is “magnetic to” the desired track.</p>

<h4 id="operation-wiring-api-track-helper" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Track()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Helper</span>

                  </h4>

<p class="">For instance, a step (or terminus) sitting on the success track will be attracting the predecessor step to connect to it.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :save,
      Output(:failure) =&gt; Track(:success)
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class=""><code class="text-purple">Track()</code> expects the track name, or the “polarization”, as we call it sometimes.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-output-47dd59642622911adf8e700211be1cd7510f9371ec219d91e72168038d8bcf25.png" /></p>

<p class="">Here, the wiring algorith will connect the <code class="text-purple">:failure</code> output of the <code class="text-purple">#save</code> step to the next available step on the <code class="text-purple">:success</code> track, which is <code class="text-purple">#notify</code>.</p>

<h4 id="operation-wiring-api-track-custom-track" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Track()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Custom Track</span>

                  </h4>

<p class="">You can build entire new tracks using a combination of <code class="text-purple">Track()</code> and <code class="text-purple">:magnetic_to</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Charge &lt; Trailblazer::Operation
    terminus :paypal # add a custom terminus (if you need it)
    step :validate
    step :find_provider,
      Output(:failure) =&gt; Track(:paypal)
    step :charge_paypal,
      magnetic_to: :paypal, Output(:success) =&gt; Track(:paypal)
    step :charge_default
    # ...
  end
end
</code></pre>

<p class="">When adding a terminus via <code class="text-purple">#terminus</code>, its “polarization” will be the same name as its semantic, <code class="text-purple">:paypal</code> in this example (this is achieved using the <code class="text-purple">:magnetic_to</code> option behind the scenes).</p>

<p class="">Next, we add <code class="text-purple">#find_provider</code> and reference <code class="text-purple">Track(:paypal)</code> for one of its outputs. This will be connected to the next possible step “magnetic to” <code class="text-purple">:paypal</code>.</p>

<p class="">To manually place a step onto that new track, you need to use <code class="text-purple">:magnetic_to</code> and <code class="text-purple">Output()</code> as it’s done with <code class="text-purple">#charge_paypal</code>.</p>

<p class="">This will compile the following operation circuit.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-custom-track-fa042c31d54e4b623e80bad6fe9e1e34aaa3767c0fe5747c5e52195d9e54a357.png" /></p>

<h3 id="operation-wiring-api-id-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Id()</span></h3>

<p class="">To explicitly connect an output to a particular step, use <code class="text-purple">Id()</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate,
      Output(:failure) =&gt; Id(:notify)
    step :save
    left :handle_errors
    step :notify
    include T.def_steps(:validate, :save, :handle_errors, :notify)
  end
end
</code></pre>

<p class="">This will, for whatever reasons, connect the failure output of <code class="text-purple">#validate</code> straight to <code class="text-purple">#notify</code>.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-id-aa5b96be7bedb1169df2cf1133d30b2e5f3977cc11f578cfe24a7febc37f8f72.png" /></p>

<p class="">Keep in mind that using <code class="text-purple">Id()</code> won’t allow inserting another step between the two just connected. If you want to insert more steps on that connection at a later point, or in a subclass, use <code class="text-purple">Track()</code>.</p>

<h3 id="operation-wiring-api-magnetic_to" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Magnetic_to</span></h3>

<p class="">Most of the times, the step DSL will wire your steps automatically. Sometimes it might be necessary to make one or several steps “snap to” a particular track.</p>

<p class="">The <code class="text-purple">:magnetic_to</code> option allows to configure what incoming connections a step attracts.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step :payment_provider, Output(:failure) =&gt; Track(:paypal)
    step :charge_paypal, magnetic_to: :paypal
    step :save
  end
end
</code></pre>

<p class="">Using this option, the <code class="text-purple">charge_paypal</code> step will not be placed on the success track, but the <code class="text-purple">paypal</code> track.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/magnetic_to-b8335133b010096415095dd49298e5043cc11e4a56e344c623875dd4e185f3dc.png" /></p>

<p class="">As you can see, outgoing connections are still automatically connected. You can use <a href="#operation-wiring-api-output-" class="underline text-purple"><code class="text-purple">Output()</code></a> to change that.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">The <code class="text-purple">:magnetic_to</code> option is very low-level and shouldn’t be used without knowing what and why you’re doing it.</p>

<p class="">Consider using the <a href="#operation-wiring-api-path-" class="underline text-purple"><code class="text-purple">Path()</code> helper</a> instead.</p>

  </div>
</div>

<h3 id="operation-wiring-api-path-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Path()</span><span class="flex max-w-fit max-h-7 border border-grey uppercase text-grey text-xs pt-1 pb-1 pl-2 pr-2 pr-1 ml-4 rounded">
            <svg class="fill-grey mt-[2px]" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M168.5 72L256 165l87.5-93h-175zM383.9 99.1L311.5 176h129L383.9 99.1zm50 124.9H256 78.1L256 420.3 433.9 224zM71.5 176h129L128.1 99.1 71.5 176zm434.3 40.1l-232 256c-4.5 5-11 7.9-17.8 7.9s-13.2-2.9-17.8-7.9l-232-256c-7.7-8.5-8.3-21.2-1.5-30.4l112-152c4.5-6.1 11.7-9.8 19.3-9.8H376c7.6 0 14.8 3.6 19.3 9.8l112 152c6.8 9.2 6.1 21.9-1.5 30.4z" /></svg>
            <a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear/tree/v1.2.0" class="ml-1" title="This feature was introduced in trailblazer-activity-dsl-linear v1.2.0.">dsl 1.2.0</a>
          </span></h3>

<p class="">For branching out a separate path in an operation, use the <code class="text-purple">Path()</code> macro. It’s a convenient, simple way to declare alternative routes, even if you could do everything it does <a href="#operation-wiring-api-track-custom-track" class="underline text-purple">manually</a>.</p>

<h4 id="operation-wiring-api-path-terminus" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Path()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Terminus</span>

                  </h4>

<p class="">You can use the <code class="text-purple">:terminus</code> option for <code class="text-purple">Path()</code> to lead the path to an existing or new terminus.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Charge &lt; Trailblazer::Operation
    step :validate
    step :find_provider,
      Output(:failure) =&gt; Path(terminus: :paypal) do
        # step :authorize # you can have multiple steps on a path.
        step :charge_paypal
      end
    step :charge_default
    # ...
  end
end
</code></pre>

<p class="">If the <code class="text-purple">#find_provider</code> steps returns false, the steps on the “paypal” path will be executed. Since we are using the <code class="text-purple">:terminus</code> option, the run stops in the new terminus <code class="text-purple">:paypal</code> .</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-path-helper-d785b87799c7fc7d07b25b0e695099a4a0a5ab9ba57fa2ee54b5a9694285e322.png" /></p>

<p class="">You don’t necessarily have to use the <code class="text-purple">:failure</code> output in order to branch out a new path. You might as well use an <a href="#operation-mechanics-flow-control-signal" class="underline text-purple">additional signal</a>, or any other predefined output of the task.</p>

<p class="">When using <code class="text-purple">Path()</code>, the steps on the path will only have one <code class="text-purple">:success</code> output. Note that there’s no connection going to the failure track from <code class="text-purple">#charge_paypal</code>.</p>

<h4 id="operation-wiring-api-path-failure" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Path()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Failure</span>

                  </h4>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">We’re working on a <code class="text-purple">:failure</code> option for <code class="text-purple">Path()</code> to allow steps with a failure output.</p>

  </div>
</div>

<h4 id="operation-wiring-api-path-connect_to" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Path()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Connect_to</span>

                  </h4>

<p class="">If you want the path to reconnect and join the railway at some point, use the <code class="text-purple">:connect_to</code> option.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Charge &lt; Trailblazer::Operation
    step :validate
    step :find_provider,
      Output(:failure) =&gt; Path(connect_to: Id(:finalize)) do
        # step :authorize # you can have multiple steps on a path.
        step :charge_paypal
      end
    step :charge_default
    step :finalize
    # ...
  end
end
</code></pre>

<p class="">Instead of creating an additional terminus, the last path step will be connected to whatever step is specified via the <code class="text-purple">Id()</code> helper.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-path-connect-to-ef7213302b4cb354535fd246b0eff7a90871502b28dc4741a917872c753fafaf.png" /></p>

<p class="">You can easily branch out and handle specific edge cases using this helper.</p>


<h3 id="operation-wiring-api-subprocess" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Subprocess</span></h3>

<p class="">While you could manually nest an operation into another, the <code class="text-purple">Subprocess()</code> macro helps to embed an operation as a step of a container operation.</p>

<p class="">Consider the following operation implementing a more complex validation. By extracting that logic to a separate operation, you’re making this code better testable, and reusable across your application.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Validate &lt; Trailblazer::Operation
    step :check_params
    step :text_present?
    # ...
  end
end
</code></pre>

<p class="">Use <code class="text-purple">Subprocess()</code> to nest it into the <code class="text-purple">Create</code> operation.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step Subprocess(Validate)
    step :save
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">The macro automatically wires all of <code class="text-purple">Validate</code>’s termini to the known counter-part tracks.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/subprocess-f7dc4519ee5f4d5a80586c8e2988728176942fdbc9c11c60c13e0ce54b8d9def.png" /></p>

<p class="">The <code class="text-purple">Subprocess</code> macro will go through all outputs of the nested operation, fetch their semantics and search for tracks with the same semantic - it’s that simple.</p>

<p class="">Note how the nested operation really acts as if it’s a plain step - in fact, the execution code doesn’t even know this is a “real” separate operation.</p>

<h4 id="operation-wiring-api-subprocess-output" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Subprocess
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Output</span>

                  </h4>

<p class="">You can use the familiar Wiring DSL to reconnect termini of the nested operation.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step Subprocess(Validate),
      Output(:failure) =&gt; Id(:notify)
    step :save
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">For demonstration purposes, the nested’s <code class="text-purple">failure</code> output now goes straight to <code class="text-purple">#notify</code>.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/subprocess-output-011cd3d37b40d24c4b22fe534777c964b786dc3aa511c29bd1bf3ed5678dc5f7.png" /></p>

<p class="">This is identical to connecting a “normal” step’s output and allows to treat particular outcomes of a nested operation in a non-standard way - for example, routing a “failed” terminus to a success path.</p>

<h4 id="operation-wiring-api-subprocess-terminus" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Subprocess
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Terminus</span>

                  </h4>

<p class="">A nested operation doesn’t have to have two termini, only.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Validate &lt; Trailblazer::Operation
    step :check_params,
      Output(:failure) =&gt; End(:invalid)
    step :text_present?
    # ...
  end
end
</code></pre>

<p class="">The <code class="text-purple">Validate</code> operation could expose a third terminus <code class="text-purple">:invalid</code> to indicate that <code class="text-purple">params</code> wasn’t formatted properly.</p>

<p class=""><code class="text-purple">Subprocess()</code> will try to match the nested termini semantics to the tracks it knows. You may wire a custom terminus like <code class="text-purple">:invalid</code> using <code class="text-purple">Output()</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step Subprocess(Validate),
      Output(:invalid) =&gt; Track(:failure)
    step :save
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">The new special terminus is now wired to the <code class="text-purple">failure</code> track of the containing <code class="text-purple">Create</code> operation.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/subprocess-terminus-ebcdde5da8b32c8479647687964835220e8c790de9b82ecffb0b0d33e66f377d.png" /></p>

<p class="">You may connect the custom terminus using any of the Wiring’s API helpers.</p>

<div class="rounded flex p-4 gap-4 bg-bg-orange">
  <img src="/assets/light_bulb_icon-86b61187949258b0b8370420dd5f5f7578f8d662e8404d553fc41813b33a5484.svg" />
  <div class="space-y-3">
    
<p class="">There will be an <code class="text-purple">IllegalSignalException</code> exception thrown at runtime time when not connecting a custom terminus. Use the <a href="#operation-wiring-api-subprocess-strict" class="underline text-purple">:strict option</a> to avoid runtime problems.</p>

  </div>
</div>

<h4 id="operation-wiring-api-subprocess-strict" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Subprocess
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Strict</span>

                  </h4>

<p class="">The <code class="text-purple">:strict</code> option is still experimental: https://github.com/trailblazer/trailblazer-activity-dsl-linear/issues/59</p>

<h4 id="operation-wiring-api-subprocess-fast-track" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Subprocess
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Fast-track</span>

                  </h4>

<p class="">When nesting another operation (or <code class="text-purple">Activity::FastTrack</code>), its fast-track temini won’t be connected automatically. Just like with a “normal” step, you need to instruct the Wiring API.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step Subprocess(Validate), fast_track: true
    step :save
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">By providing <code class="text-purple">fast_track: true</code>, the nested termini will be connected to the matching outer tracks.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/wiring-subprocess-fast-track-e38619b4659f01b95a4211b9e51dac0bdd5766eaa6d4c038b59739c143a07936.png" /></p>

<p class="">Omitting this option is usually the source for an <code class="text-purple">IllegalSignalError</code> at run-time.</p>

<h3 id="operation-wiring-api-fast-track" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Fast-track</span></h3>

<p class="">The operation is based on the <a href="#operation-internals-fasttrack-layout" class="underline text-purple"><code class="text-purple">FastTrack</code> layout</a> and provides three more options for configuring a step’s connections.</p>

<h4 id="operation-wiring-api-fast-track-pass_fast" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Fast-track
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">pass_fast</span>

                  </h4>

<p class="">The <code class="text-purple">:pass_fast</code> option wires the <code class="text-purple">:success</code> output straight to the new <code class="text-purple">pass_fast</code> terminus.</p>

<div class="spacing-y-0"><div class="spacing-x-1 mb-[6px]">
            <a href="#" data-toggle="code-tab" data-type="code-tab-activity">
              <span class="font-semi-bold bg-bg-purple-1 p-2 rounded-t" data-show="code-tab-activity" data-hide="code-tab-operation" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Activity</span>
            </a>
            <a href="#" data-toggle="code-tab" data-type="code-tab-operation">
              <span class="font-semi-bold bg-[#E4E4E4] p-2 rounded-t" data-show="code-tab-operation" data-hide="code-tab-activity" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Operation</span>
            </a>
          </div><div class="code-tab-activity code-tab-content"><pre class=""><code class="rounded-tr rounded-b">module Memo::Activity
  class Create &lt; Trailblazer::Activity::FastTrack
    step :validate, pass_fast: true
    step :save
    fail :handle_errors
    # ...
  end
end
</code></pre></div><div class="code-tab-operation code-tab-content hidden"><pre class=""><code class="rounded-tr rounded-b">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate, pass_fast: true
    step :save
    fail :handle_errors
    # ...
  end
end
</code></pre></div></div>

<p class="">If <code class="text-purple">validate</code> returns a true value, it will skip the remaining tasks on the success track and terminate in the <code class="text-purple">pass_fast</code> terminus.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/pass_fast-e2f3d017f376964532d9b4a0303696c5753e873cf6812cf6f945516f4fbbd70c.png" /></p>

<p class="">Note that in the example, the <code class="text-purple">#save</code> step not accessable anymore, so maybe it’s a good idea to refrain from such a layout.</p>

<h4 id="operation-wiring-api-fast-track-fail_fast" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Fast-track
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">fail_fast</span>

                  </h4>

<p class="">The counter-part for <code class="text-purple">:pass_fast</code> is <code class="text-purple">:fail_fast</code> and allows to instantly stop the operation.</p>

<div class="spacing-y-0"><div class="spacing-x-1 mb-[6px]">
            <a href="#" data-toggle="code-tab" data-type="code-tab-activity">
              <span class="font-semi-bold bg-bg-purple-1 p-2 rounded-t" data-show="code-tab-activity" data-hide="code-tab-operation" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Activity</span>
            </a>
            <a href="#" data-toggle="code-tab" data-type="code-tab-operation">
              <span class="font-semi-bold bg-[#E4E4E4] p-2 rounded-t" data-show="code-tab-operation" data-hide="code-tab-activity" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Operation</span>
            </a>
          </div><div class="code-tab-activity code-tab-content"><pre class=""><code class="rounded-tr rounded-b">module Memo::Activity
  class Create &lt; Trailblazer::Activity::FastTrack
    step :validate, fail_fast: true
    step :save
    fail :handle_errors
    # ...
  end
end
</code></pre></div><div class="code-tab-operation code-tab-content hidden"><pre class=""><code class="rounded-tr rounded-b">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :validate, fail_fast: true
    step :save
    fail :handle_errors
    # ...
  end
end
</code></pre></div></div>

<p class="">A falsey return value from <code class="text-purple">#validate</code> will deviate the flow and go straight to the <code class="text-purple">fail_fast</code> terminus.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/fail_fast-f035cf41dabb9b9d4ec48fe959efd95609c9436737f53de61a33ff8babef605b.png" /></p>

<p class="">Even though <code class="text-purple">#handle_errors</code> is on the failure track, it won’t be reached from <code class="text-purple">#validate</code>.</p>

<h4 id="operation-wiring-api-fast-track-fast_track" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Fast-track
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">fast_track</span>

                  </h4>

<p class="">When setting the <code class="text-purple">:fast_track</code> option, a step will have four outputs and, obviously, can have four outcomes. The additional fast-track outputs you can indicate by <a href="#operation-mechanics-flow-control-signal" class="underline text-purple">returning a well-defined signal</a>.</p>

<div class="spacing-y-0"><div class="spacing-x-1 mb-[6px]">
            <a href="#" data-toggle="code-tab" data-type="code-tab-activity">
              <span class="font-semi-bold bg-bg-purple-1 p-2 rounded-t" data-show="code-tab-activity" data-hide="code-tab-operation" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Activity</span>
            </a>
            <a href="#" data-toggle="code-tab" data-type="code-tab-operation">
              <span class="font-semi-bold bg-[#E4E4E4] p-2 rounded-t" data-show="code-tab-operation" data-hide="code-tab-activity" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Operation</span>
            </a>
          </div><div class="code-tab-activity code-tab-content"><pre class=""><code class="rounded-tr rounded-b">class Create &lt; Trailblazer::Activity::FastTrack
  module Memo::Activity
    class Create &lt; Trailblazer::Activity::FastTrack
      step :validate, fast_track: true
      step :save
      fail :handle_errors

      def validate(ctx, params:, **)
        return Trailblazer::Activity::FastTrack::FailFast if params.nil? #!hint return Railway.fail_fast! if params.nil?

        params.key?(:memo)
      end
      # ...
    end
  end
end
</code></pre></div><div class="code-tab-operation code-tab-content hidden"><pre class=""><code class="rounded-tr rounded-b">class Create &lt; Trailblazer::Operation
  module Memo::Operation
    class Create &lt; Trailblazer::Operation
      step :validate, fast_track: true
      step :save
      fail :handle_errors

      def validate(ctx, params:, **)
        return Railway.fail_fast! if params.nil?

        params.key?(:memo)
      end
      # ...
    end
  end
end
</code></pre></div></div>

<p class="">The <code class="text-purple">validate</code> step now has four outputs. You can instruct the two new fast-track outputs by returning either <code class="text-purple">Railway.fail_fast!</code> or <code class="text-purple">Railway.pass_fast!</code>.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">When using the slimmer <code class="text-purple">Activity::FastTrack</code> layout, you won’t have access to <code class="text-purple">Railway.pass_fast!</code>. Either use the fully-qualified constant <code class="text-purple">Trailblazer::Operation::Railway.pass_fast!</code> to reference the signal, or return <code class="text-purple">Trailblazer::Activity::FastTrack::PassFast</code> (see “Activity” code tab above).</p>

  </div>
</div>

<p class="">Note that you don’t have to use both outputs.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/fast_track-aab09273049fb03d465dac4afeece09ef1caca669a21d7b448a59a631c582cda.png" /></p>

<p class="">The fast-track layout is an attempt to implement best practices. Most of the times, however, you can achieve a similar result using a <a href="#operation-wiring-api-track-" class="underline text-purple">separate track</a> or terminus.</p>

<h2 id="operation-variable-mapping" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Variable Mapping</span><span class="flex max-w-fit max-h-7 border border-grey uppercase text-grey text-xs pt-1 pb-1 pl-2 pr-2 pr-1 ml-4 rounded">
            <svg class="fill-grey mt-[2px]" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M168.5 72L256 165l87.5-93h-175zM383.9 99.1L311.5 176h129L383.9 99.1zm50 124.9H256 78.1L256 420.3 433.9 224zM71.5 176h129L128.1 99.1 71.5 176zm434.3 40.1l-232 256c-4.5 5-11 7.9-17.8 7.9s-13.2-2.9-17.8-7.9l-232-256c-7.7-8.5-8.3-21.2-1.5-30.4l112-152c4.5-6.1 11.7-9.8 19.3-9.8H376c7.6 0 14.8 3.6 19.3 9.8l112 152c6.8 9.2 6.1 21.9-1.5 30.4z" /></svg>
            <a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear/tree/v1.2.0" class="ml-1" title="This feature was introduced in trailblazer-activity-dsl-linear v1.2.0.">dsl 1.2.0</a>
          </span></h2>

<p class="">Since TRB 2.1 it is possible to define the input and output variables for each step. This is called <em>variable mapping</em>, or I/O in short. It provides an interface to define what variables go in and come out of a task, enabling you to limit what steps “see” and what “output” they can add to the context.</p>

<p class="">It’s one of the most frequently used features in Trailblazer.</p>

<h3 id="operation-variable-mapping-overview" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Overview</span></h3>

<p class="">Imagine a complex application where policies are protecting your operation code from unsolicited access. This code component - the policy - sits as a step in every business operation and decides whether or not the current user is permitted to execute this very operation.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create # an imaginary policy step.
    # ...
  end
end
</code></pre>

<p class="">The <code class="text-purple">Policy::Create</code> implementation is a simple callable class following the <a href="#operation-internals-step-interface" class="underline text-purple">step interface</a>.</p>

<pre class=""><code class="rounded">module Policy
  # Explicit policy, not ideal as it results in a lot of code.
  class Create
    def self.call(ctx, model:, user:, **)
      decision = ApplicationPolicy.can?(model, user, :create) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p class="">Note that it requires two variables <code class="text-purple">:model</code> and <code class="text-purple">:user</code> from the ctx. For whatever reasons, the author of this class dictated that the “current user” must be passed named <code class="text-purple">:user</code>, not, as it’s a convention in Trailblazer, named <code class="text-purple">:current_user</code>.</p>

<p class="">Last, depending on the policy decision, the step code returns true or false.</p>

<p class="">When executing the <code class="text-purple">Create</code> operation using the <code class="text-purple">:current_user</code> variable, an <code class="text-purple">ArgumentError</code> is raised.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(current_user: Module)

#=&gt; ArgumentError: missing keyword: :user
</code></pre>

<p class="">Since the “current user” is handed into the operation as the <code class="text-purple">:current_user</code> variable, and no other step preceding <code class="text-purple">Policy::Create</code> is setting this variable, the step expecting <code class="text-purple">:user</code> crashes.</p>

<p class="">And this is why we need variable mapping in Trailblazer.</p>

<h3 id="operation-variable-mapping-composable-i-o" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Composable I/o</span></h3>

<p class="">Variable mapping (short: i/o) can be done manually, with ugly “helper” steps before or after the respective step, or by using <code class="text-purple">In()</code>, <code class="text-purple">Out()</code> and <code class="text-purple">Inject()</code>. Before these helpers got introduced, we used the <code class="text-purple">:input</code> and <code class="text-purple">:output</code> option - both works, the latter one coming with several drawbacks.</p>

<p class="">Helpers can be used multiple times, depending on how complex the incoming or outcoming variables are, forming a pipeline of filters around the actual task.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message]
    # ...
  end
end
</code></pre>

<p class="">Not only are those input and output pipelines easy to <a href="#operation-variable-mapping-introspect" class="underline text-purple">debug</a>, they also allow to be altered in derived operations, when <a href="#operation-variable-mapping-inheritance" class="underline text-purple">using inheritance</a>, and  work in <a href="#operation-variable-mapping-macro" class="underline text-purple">combination with macros</a>.</p>

<h3 id="operation-variable-mapping-in-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">In()</span></h3>

<p class=""><code class="text-purple">In()</code> allows to configure variables going <em>into</em> the step. The helper accepts either a mapping hash, a limiting array or a callable object (often a lambda), to compute variables at runtime.</p>

<div class="rounded flex p-4 gap-4 bg-bg-orange">
  <img src="/assets/light_bulb_icon-86b61187949258b0b8370420dd5f5f7578f8d662e8404d553fc41813b33a5484.svg" />
  <div class="space-y-3">
    
<p class="">Be wary that once you <strong>use <code class="text-purple">In()</code> your are white-listing</strong>: only the variables defined in your filters will be passed into the step. All other variables from ctx are invisible in the step.</p>

  </div>
</div>

<h4 id="operation-variable-mapping-in-mapping-hash" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">In()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Mapping hash</span>

                  </h4>

<p class="">Picking up the example from above, here’s how a mapping hash “translates” the selected variables from the original ctx object to a new ctx, one that is compatible with <code class="text-purple">Policy::Create</code>’s interface.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Operation
  step :create_model
  step Policy::Create,
    In() =&gt; {
      :current_user =&gt; :user, # rename {:current_user} to {:user}
      :model        =&gt; :model # add {:model} to the inner ctx.
    }
  # ...
end
</code></pre>

<p class="">The <code class="text-purple">In()</code> filter will result in <code class="text-purple">:current_user</code> being renamed to <code class="text-purple">:user</code>. Since the policy step also needs <code class="text-purple">:model</code> we need to mention this variable as well, no renaming happening here. The beauty of I/O: this is only visible to <code class="text-purple">Policy::Create</code>!</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/ctx-in-7d4b12e96d0794df8f525c8f021da2d37834bee7bbfb86fba8698f580e8a77c6.png" /></p>

<p class="">To instantly see what new ctx is passed into the configured step, you could replace the original policy step with a <code class="text-purple">#show_ctx</code> method.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step :show_ctx,
      In() =&gt; {
        :current_user =&gt; :user, # rename {:current_user} to {:user}
        :model        =&gt; :model # add {:model} to the inner ctx.
      }

    def show_ctx(ctx, **)
      p ctx.to_h
      #=&gt; {:user=&gt;#&lt;User email:...&gt;, :model=&gt;#&lt;Memo name=nil&gt;}
    end
    # ...
  end
end
</code></pre>

<p class="">You should use the mapping hash when variables need to be renamed. If variables need to be added without renaming, a limiting array is your friend.</p>

<h4 id="operation-variable-mapping-in-limiting-array" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">In()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Limiting array</span>

                  </h4>

<p class=""><code class="text-purple">In()</code> accepts an array, listed variables are passed into the new ctx (whether they exist in the original ctx or not!).</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model]
    # ...
  end
end
</code></pre>

<p class="">This configuration will lead to the exact same new ctx for <code class="text-purple">Policy::Create</code> as in the <a href="#operation-variable-mapping-in-mapping-hash" class="underline text-purple">example above</a>, producing a new ctx that will look as below.</p>

<pre class=""><code class="rounded">
#=&gt; {
#     :user  =&gt; #&lt;User email:...&gt;,
#     :model =&gt; #&lt;Song name=nil&gt;}
#   }</code></pre>

<h4 id="operation-variable-mapping-in-callable" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">In()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Callable</span>

                  </h4>

<p class="">As always, you may implement your own input filter with any callable object <a href="#operation-internals-step-interface" class="underline text-purple">adhering to the step interface</a>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; -&gt;(ctx, **) do
        # only rename {:current_user} if it's there.
        ctx[:current_user].nil? ? {} : {user: ctx[:current_user]}
      end,
      In() =&gt; [:model]
    # ...
  end
end
</code></pre>

<p class="">Callable <code class="text-purple">In()</code> filters <strong>have to</strong> return a hash. This hash will be merged with the other <code class="text-purple">In()</code> filters and comprise the new ctx.</p>

<p class="">And again, when the operation is invoked with a <code class="text-purple">:current_user</code>, this will, result in the same new ctx as above.</p>

<pre class=""><code class="rounded">
#=&gt; {
#     :user  =&gt; #&lt;User email:...&gt;,
#     :model =&gt; #&lt;Song name=nil&gt;}
#   }</code></pre>

<p class="">However, if <code class="text-purple">:current_user</code> is <code class="text-purple">nil</code>, <code class="text-purple">Policy::Create</code> will raise an exception complaining about the <code class="text-purple">:user</code> keyword missing.</p>

<h4 id="operation-variable-mapping-in-filter-method" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">In()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Filter method</span>

                  </h4>

<p class="">Following the TRB option standard, an <code class="text-purple">In()</code> filter may even be implemented as an instance method. All you need to do is pass a symbol to <code class="text-purple">In()</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; :input_for_policy, # You can use an {:instance_method}!
      In() =&gt; [:model]

    def input_for_policy(ctx, **)
      # only rename {:current_user} if it's there.
      ctx[:current_user].nil? ? {} : {user: ctx[:current_user]}
    end
    # ...
  end
end
</code></pre>

<p class="">The method needs to expose a step interface just like any other callable.</p>

<h4 id="operation-variable-mapping-in-keyword-arguments" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">In()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Keyword arguments</span>

                  </h4>

<p class="">Both callables and filter methods for <code class="text-purple">In()</code> can receive ctx variables as keyword arguments, making it a convenient access and have Ruby perform a loose existance test automatically.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
                    # vvvvvvvvvvvv keyword arguments rock!
      In() =&gt; -&gt;(ctx, current_user: nil, **) do
        current_user.nil? ? {} : {user: current_user}
      end,
      In() =&gt; [:model]
    # ...
  end
end
</code></pre>

<p class="">Keep in mind that when not defaulting the keyword argument your filter might crash at runtime when the expected variables were not passed.</p>

<h3 id="operation-variable-mapping-out-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Out()</span></h3>

<p class="">Without any output configuration on the exemplary policy step, any variable written to <code class="text-purple">ctx</code> will be automatically set on the outer ctx, passing along internal variabes to the following step.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/ctx-out-all-d2ddf6c9b6b68d02600517a8a5a3d5ff0adc51fa81b3a8dc67213c51f2d22615.png" /></p>

<p class="">Here, both <code class="text-purple">:status</code> and <code class="text-purple">:message</code> variables that were written in <code class="text-purple">Policy::Create</code> are passed into the outer ctx. The behavior is identical to the way before you were using i/o.</p>

<p class="">However, it is often necessary to rename or limit the outgoing variables of a particular step. Especially when using nested operations you probably don’t want the entire nested ctx to be copied into the outer context. This is where output filters enter the stage.</p>

<p class="">Consider the following updated <code class="text-purple">Policy::Create</code> step.</p>

<pre class=""><code class="rounded">module Policy
  # Explicit policy, not ideal as it results in a lot of code.
  class Create
    def self.call(ctx, model:, user:, **)
      decision = ApplicationPolicy.can?(model, user, :create) # FIXME: how does pundit/cancan do this exactly?

      if decision.allowed?
        return true
      else
        ctx[:status]  = 422 # we're not interested in this field.
        ctx[:message] = "Command {create} not allowed!"
        return false
      end
    end
  end
end
</code></pre>

<p class="">Both <code class="text-purple">ctx[:status]</code> and <code class="text-purple">ctx[:message]</code> will be visible in all steps following <code class="text-purple">Policy::Create</code>. This might lead to “misunderstandings” and bugs in more complex applications.</p>

<p class="">As soon as you use <code class="text-purple">Out()</code>, only variables specified through the filters will be merged with the original (outer) ctx and passed on to the next step.</p>

<h4 id="operation-variable-mapping-out-limiting-array" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Out()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Limiting array</span>

                  </h4>

<p class="">In order to limit variables added to the outer ctx, <code class="text-purple">Out()</code> accepts an array similar to <code class="text-purple">In()</code>. Consider this as a whitelisting to specify exposed variables.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message]
    # ...
  end
end
</code></pre>

<p class="">This single <code class="text-purple">Out()</code> usage will result in only the <code class="text-purple">:message</code> variable being written to the outer ctx that is passed on. The <code class="text-purple">:status</code> variable is discarded.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/ctx-out-5f24f390da6bdab0bdfd5bb752fe3312a47941a0736c585e2e3c164c5d73f744.png" /></p>

<p class="">You may pass any number of variables in the limiting array.</p>

<h4 id="operation-variable-mapping-out-mapping-hash" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Out()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Mapping hash</span>

                  </h4>

<p class="">Renaming variables from the inner to the outer ctx works by providing a mapping hash, where the “old” inner name points to the outer name that you want to use in the operation hosting that step.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; {:message =&gt; :message_from_policy}
    # ...
  end
end
</code></pre>

<p class="">Here, steps following <code class="text-purple">Policy::Create</code> will see a variable <code class="text-purple">:message_from_policy</code> merged into the ctx - which is the original <code class="text-purple">:message</code>, renamed.</p>

<h4 id="operation-variable-mapping-out-callable" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Out()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Callable</span>

                  </h4>

<p class="">An <code class="text-purple">Out()</code> filter can be any callable object following the <a href="#operation-internals-step-interface" class="underline text-purple">step interface</a>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; -&gt;(ctx, **) do
        return {} unless ctx[:message]

        { # you always have to return a hash from a callable!
          :message_from_policy =&gt; ctx[:message]
        }
      end
    # ...
  end
end
</code></pre>

<p class="">The callable receives the inner ctx that just left the actual step, here <code class="text-purple">Policy::Create</code>. You may run any Ruby code in the callable, even <code class="text-purple">if</code>s.</p>

<p class="">Note that a callable always must return a hash, which is then merged with the original outer ctx.</p>

<p class="">Be adviced that it is usually a better idea to maintain multiple smaller <code class="text-purple">Out()</code> callables for different variables. You might later decide to override them, debugging will be easier and the code is more maintainable. This was different when <code class="text-purple">:output</code> was the only way to filter outgoing variables and you had to create one big hash in a one single filter.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">You may also use an <code class="text-purple">:instance_method</code> to filter outgoing variables, similar to <a href="#operation-variable-mapping-in-filter-method" class="underline text-purple">how it’s done with In()</a>.</p>

  </div>
</div>

<h4 id="operation-variable-mapping-out-keyword-arguments" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Out()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Keyword arguments</span>

                  </h4>

<p class="">Just as with <code class="text-purple">In()</code> callables can receive keyword arguments.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; -&gt;(ctx, message: nil, **) do
        return {} if message.nil?

        { # you always have to return a hash from a callable!
          :message_from_policy =&gt; message
        }
      end
    # ...
  end
end
</code></pre>

<p class="">Any variable readable on the inner <code class="text-purple">ctx</code> that just left <code class="text-purple">Policy::Create</code> is available as a keyword argument for a callable. Note that you need to default it if its presence is not guaranteed.</p>

<h4 id="operation-variable-mapping-out-outer-context" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Out()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Outer context</span>

                  </h4>

<p class="">You can access the outer, original ctx by passing the <code class="text-purple">:with_outer_ctx</code> option to <code class="text-purple">Out()</code>.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message],

      Out(with_outer_ctx: true) =&gt; -&gt;(inner_ctx, outer_ctx:, **) do
        {
          errors: outer_ctx[:errors].merge(policy_message: inner_ctx[:message])
        }
      end
    # ...
  end
end
</code></pre>

<p class="">While the callable still needs to return a hash that is then merged with the original ctx, it’s possible to access variables from the outer ctx through the <code class="text-purple">:outer_ctx</code> keyword argument. This allows for merging deeper data structures, such as error objects.</p>

<h3 id="operation-variable-mapping-inject-" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Inject()</span></h3>

<p class="">An <code class="text-purple">Inject()</code> filter, as opposed to <code class="text-purple">In()</code>, does an existance check on the ctx using <code class="text-purple">ctx.key?(:variable)</code> before performing its logic. It is helpful in combination with <code class="text-purple">In()</code> filters, when using defaulted keyword arguments in a step or in nested operations.</p>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">It allows defaulting a variable when it’s absent in the ctx.</li>
  <li class="list-image-disc ml-10">It can pass-through a variable when it is present in the ctx, and only then.</li>
  <li class="list-image-disc ml-10">You can also statically set a variable, whether or not it is present using the <code class="text-purple">:override</code> option.</li>
</ul>

<p class="">Note that <code class="text-purple">Inject()</code> can be used without <code class="text-purple">In()</code>.</p>

<p class="">Check the following exemplary policy code.</p>

<pre class=""><code class="rounded">module Policy
  class Check
                                    # vvvvvvvvvvvvvvv-- defaulted keyword arguments
    def self.call(ctx, model:, user:, action: :create, **)
      decision = ApplicationPolicy.can?(model, user, action) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p class="">This policy implementation uses keyword arguments to automatically extract <code class="text-purple">:model</code>, <code class="text-purple">:user</code> and <code class="text-purple">:action</code> from the ctx. Note that the latter is defaulted to <code class="text-purple">:create</code>. Defaulting kwargs only works when the keyword variable is <strong>not passed</strong> into the step - if it’s <code class="text-purple">nil</code>, the defaulting will not get triggered.</p>

<p class="">You could now use <code class="text-purple">In()</code> filters to embed this policy step into your operation.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model, :action]
    # ...
  end
end
</code></pre>

<p class="">However, this will break because the <code class="text-purple">action</code> variable will never be defaulted to <code class="text-purple">:create</code>. The <code class="text-purple">In()</code> filter will <em>always</em> pass <code class="text-purple">:action</code> through when calling the policy, even when it’s absent.</p>

<p class="">The <code class="text-purple">Inject()</code> helper is designed to handle this case.</p>

<h4 id="operation-variable-mapping-inject-array-style" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Inject()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Array style</span>

                  </h4>

<p class="">Use <code class="text-purple">Inject()</code> in combination with <code class="text-purple">In()</code> to add variables to the filtered ctx, but only when they’re present in the outer ctx.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Inject() =&gt; [:action]
    # ...
  end
end
</code></pre>

<p class="">We call this <em>qualified pass-through</em>, it means the <code class="text-purple">:action</code> variable will only be passed into the filtered ctx if it exists on <code class="text-purple">ctx</code> when the filter is invoked.</p>

<h4 id="operation-variable-mapping-inject-defaulting" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Inject()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Defaulting</span>

                  </h4>

<p class="">Instead of hard-wiring defaulted keyword arguments into your step implementations, you can configure <code class="text-purple">Inject()</code> to set a default value to variables, if they’re absent in the ctx.</p>

<p class="">Here’s an example policy without any defaulting in the signature.</p>

<pre class=""><code class="rounded">module Policy
  class Check
                                    # vvvvvvv-- no defaulting!
    def self.call(ctx, model:, user:, action:, **)
      decision = ApplicationPolicy.can?(model, user, action) # FIXME: how does pundit/cancan do this exactly?
      # ...
    end
  end
end
</code></pre>

<p class="">Defaulting the <code class="text-purple">:action</code> variable via <code class="text-purple">Inject()</code> will improve the policy component’s reusability.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Inject(:action) =&gt; -&gt;(ctx, **) { :create }
    # ...
  end
end
</code></pre>

<p class="">The lambda is executed at runtime, just before the actual step is invoked. It provides access to the ctx object and allows extracting keyword arguments.</p>

<h4 id="operation-variable-mapping-inject-override" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Inject()
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Override</span>

                  </h4>

<p class="">Use the <code class="text-purple">:override</code> option to always set a variable, even if it is already present in the incoming <code class="text-purple">ctx</code>.</p>

<pre class=""><code class="rounded">Inject(:action, override: true) =&gt; -&gt;(*) { :create } # always used.
</code></pre>

<p class="">This is helpful to set configuration variables for an activity while still using the well-established keyword argument mechanics. The <code class="text-purple">Policy::Create</code> class defines <code class="text-purple">:action</code> as a kwarg. This doesn’t necessarily mean the user can always inject and dictate the very value. Instead, we can override any injected value with the “hard-coded” <code class="text-purple">:create</code> value.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Check,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Inject(:action, override: true) =&gt; -&gt;(*) { :create } # always used.
    # ...
  end
end
</code></pre>

<p class="">The call as below will always use <code class="text-purple">action: :create</code>, even if something else is injected.</p>

<pre class=""><code class="rounded">result = Memo::Operation::Create.(
  current_user: current_user,
  action: :update # this is always overridden.
)
puts result[:model] #=&gt; #&lt;Memo id: 1, ...&gt;
</code></pre>

<h3 id="operation-variable-mapping-macro" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Macro</span></h3>

<p class="">As all DSL options the <code class="text-purple">In()</code>, <code class="text-purple">Out()</code> and <code class="text-purple">Inject()</code> helpers can be used from macros, providing the macro author a convenient way to define default filters.</p>

<pre class=""><code class="rounded">module Policy
  def self.Create()
    {
      task: Policy::Create,
      wrap_task: true,
      Trailblazer::Activity::Railway.In()  =&gt; {:current_user =&gt; :user},
      Trailblazer::Activity::Railway.In()  =&gt; [:model],
      Trailblazer::Activity::Railway.Out() =&gt; {:message =&gt; :message_from_policy},
    }
  end
end
</code></pre>

<p class="">In the options hash that a macro must return, you can use the helpers by referencing <code class="text-purple">Trailblazer::Activity::Railway</code>. Except for the prefixed constant, there is no difference or limitation to their usage.</p>

<p class="">They can be extended with options the macro user provides.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation
    step :create_model
    step Policy::Create(),
      Out() =&gt; {:message =&gt; :copied_message} # user options!
    # ...
  end
end
</code></pre>

<p class="">The user options will be merged into the macro options, resulting in <code class="text-purple">:message</code> being renamed to <code class="text-purple">:message_from_policy</code> and copied to <code class="text-purple">:copied_message</code>.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Before <code class="text-purple">trailblazer-activity-dsl-linear-1.0.0</code> and the <code class="text-purple">In()</code> and <code class="text-purple">Out()</code> helper shipped with it, any <code class="text-purple">:input</code> from the user would always override the macro’s <code class="text-purple">:input</code> option.</p>

  </div>
</div>

<h3 id="operation-variable-mapping-inheritance" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Inheritance</span></h3>

<p class="">Subclasses can add and remove input and output filters - hence the term <em>composable</em>. This is a great tool when inherited operations replace particular steps and need to fine-tune ingoing or returned variables.</p>

<p class="">Consider the following base operation.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Operation

    step :create_model
    step Policy::Create,
      In() =&gt; {:current_user =&gt; :user},
      In() =&gt; [:model],
      Out() =&gt; [:message],
      id: :policy
    # ...
  end
end
</code></pre>

<p class="">It defines two input and one output filter.</p>

<p class="">A sub operation could now replace the policy step. However, instead of redefining the i/o filters, they can be inherited and extended.</p>

<p class="">Here’s a potential inheriting operation.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Admin &lt; Create
    step Policy::Create,
      Out() =&gt; {:message =&gt; :raw_message_for_admin},
      inherit: [:variable_mapping],
      id: :policy,      # you need to reference the :id when your step
      replace: :policy
  end
end
</code></pre>

<p class="">This configuration is adding another <code class="text-purple">Out()</code> filter, resulting in a total filter setup as follows in the introspection.</p>

<pre class=""><code class="rounded">puts Trailblazer::Developer::Render::TaskWrap.(Memo::Operation::Admin, id: :policy)

Memo::Operation::Admin
# `-- policy
#     |-- task_wrap.input..................Trailblazer::Operation::DSL::Linear::VariableMapping::Pipe::Input
#     |   |-- input.init_hash.............................. ............................................. VariableMapping.initial_aggregate
#     |   |-- input.add_variables.0.994[...]............... {:current_user=&gt;:user}....................... VariableMapping::AddVariables
#     |   |-- input.add_variables.0.592[...]............... [:model]..................................... VariableMapping::AddVariables
#     |   `-- input.scope.................................. ............................................. VariableMapping.scope
#     |-- task_wrap.call_task..............Method
#     `-- task_wrap.output.................Trailblazer::Operation::DSL::Linear::VariableMapping::Pipe::Output
#         |-- output.init_hash............................. ............................................. VariableMapping.initial_aggregate
#         |-- output.add_variables.0.599[...].............. [:message]................................... VariableMapping::AddVariables::Output
#         |-- output.add_variables.0.710[...].............. {:message=&gt;:raw_message_for_admin}........... VariableMapping::AddVariables::Output
#        `-- output.merge_with_original................... ............................................. VariableMapping.merge_with_original
</code></pre>

<p class="">The new <code class="text-purple">Out()</code> filter setting <code class="text-purple">:raw_message_for_admin</code> is placed behind the inherited filter.</p>

<p class="">Note that <code class="text-purple">inherit: true</code> will, besides other options, also invoke the variable mapping inheritance.</p>

<!--


TODO: decompose trick (input )
-->

<h3 id="operation-variable-mapping-introspect" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Introspect</span></h3>

<p class="">You can visualize the pipelines around each step by using the <code class="text-purple">trailblazer-developer</code> gem.</p>

<pre class=""><code class="rounded">puts Trailblazer::Developer::Render::TaskWrap.(Memo::Operation::Create, id: :policy)
</code></pre>

<p class="">This handy invocation will render the task wrap around <code class="text-purple">Song::Operation::Create</code>’s step <code class="text-purple">:policy</code>.</p>

<pre class=""><code class="rounded">Memo::Operation::Create
`-- policy
    |-- task_wrap.input..................Trailblazer::Operation::DSL::Linear::VariableMapping::Pipe::Input
    |   |-- input.init_hash.............................. ............................................. VariableMapping.initial_aggregate
    |   |-- input.add_variables.0.994[...]............... {:current_user=&gt;:user}....................... VariableMapping::AddVariables
    |   |-- input.add_variables.0.592[...]............... [:model]..................................... VariableMapping::AddVariables
    |   `-- input.scope.................................. ............................................. VariableMapping.scope
    |-- task_wrap.call_task..............Method
    `-- task_wrap.output.................Trailblazer::Operation::DSL::Linear::VariableMapping::Pipe::Output
        |-- output.init_hash............................. ............................................. VariableMapping.initial_aggregate
        |-- output.add_variables.0.599[...].............. [:message]................................... VariableMapping::AddVariables::Output
        `-- output.merge_with_original................... ............................................. VariableMapping.merge_with_original
</code></pre>

<p class="">In i/o context, the interesting branches here are <code class="text-purple">task_wrap.input</code> and <code class="text-purple">task_wrap.output</code>. Sandwiched between generic library steps are your filter steps. The visualizer even renders filter configuration where possible.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">We’re planning improvements on this part of <code class="text-purple">trailblazer-developer</code>. If you want to help out with better rendering, please <a href="https://trailblazer.zulipchat.com" class="underline text-purple">come chat to us</a>.</p>

  </div>
</div>

<h2 id="operation-macro-api" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Macro API</span></h2>

<p class="">Macros are short-cuts for inserting a task along with options into your activity.</p>

<h3 id="operation-macro-api-definition" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Definition</span></h3>

<p class="">They’re simple functions that return a hash with options described here.</p>

<pre class=""><code class="rounded">module MyMacro
  def self.NormalizeParams(name: :myparams, merge_hash: {})
    task = -&gt;((ctx, flow_options), _) do
      ctx[name] = ctx[:params].merge(merge_hash)

      return Trailblazer::Activity::Right, [ctx, flow_options]
    end

    # new API
    {
      task: task,
      id:   name
    }
  end
end
</code></pre>

<p class="">Two required options are <code class="text-purple">:id</code> and <code class="text-purple">:task</code>, the latter being the actual task you want to insert. The callable task needs to implement the [circuit interface].</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Please note that the actual task doesn’t have to be a proc! Use a class, constant, object, as long as it exposes a <code class="text-purple">#call</code> method it will flow.</p>

  </div>
</div>

<h3 id="operation-macro-api-usage" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Usage</span></h3>

<p class="">To actually apply the macro you call the function in combination with <code class="text-purple">step</code>, <code class="text-purple">pass</code>, <code class="text-purple">fail</code>, etc.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step MyMacro::NormalizeParams(merge_hash: {role: "sailor"})
end
</code></pre>

<p class="">There’s no additional logic from Trailblazer happening here. The function returns a well-defined hash which is passed as an argument to <code class="text-purple">step</code>.</p>

<h3 id="operation-macro-api-options" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Options</span></h3>

<p class="">In the returned hash you may insert any valid DSL [step option], such as sequence options like <code class="text-purple">:before</code>, <code class="text-purple">Output()</code> and friends from the wiring API or even <code class="text-purple">:extensions</code>.</p>

<p class="">The following <code class="text-purple">FindModel</code> macro retrieves a configured model just like <code class="text-purple">trailblazer-macro</code>’s <code class="text-purple">Model()</code> and automatically wires the step’s <code class="text-purple">failure</code> output to a new terminus <code class="text-purple">not_found</code>.</p>

<pre class=""><code class="rounded">module MyMacro
  def self.FindModel(model_class)
    # the inserted task.
    task = -&gt;((ctx, flow_options), _) do
      model         = model_class.find_by(id: ctx[:params][:id])

      return_signal = model ? Trailblazer::Activity::Right : Trailblazer::Activity::Left
      ctx[:model]   = model

      return return_signal, [ctx, flow_options]
    end

    # the configuration needed by Trailblazer's DSL.
    {
      task: task,
      id:   :"find_model_#{model_class}",
      Trailblazer::Activity::Railway.Output(:failure) =&gt; Trailblazer::Activity::Railway.End(:not_found)
    }
  end
end
</code></pre>

<p class="">See how you can simply add <code class="text-purple">Output</code> wirings by using the well-established mechanics from the wiring API? Remember you’re not in an <code class="text-purple">Activity</code> or <code class="text-purple">Operation</code> namespace and hence need to use the fully-qualified constant reference <code class="text-purple">Trailblazer::Activity::Railway.Output()</code>.</p>

<p class="">To insert that step and its extended wiring, simply call the macro.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step MyMacro::FindModel(User)
end
</code></pre>

<p class="">When running the activity without a valid model ID, it will now terminate on <code class="text-purple">End.not_found</code>.</p>

<pre class=""><code class="rounded">signal, (ctx, _) = Trailblazer::Developer.wtf?(User::Create, [{params: {id: nil}}])
signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:not_found&gt;

`-- User::Create
    |-- Start.default
    |-- find_model_User
    `-- End.not_found
</code></pre>

<p class="">Using the wiring API in your own macros gives you a powerful tool for harnessing extended wiring without requiring the user to know about the details - the crucial point for a good API.</p>

<h4 id="operation-macro-api-options-subprocess" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Options
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Subprocess</span>

                  </h4>

<p class="">You can even use other macros in custom macros, such as the <a href="#operation-wiring-api-subprocess" class="underline text-purple"><code class="text-purple">Subprocess()</code> helper</a> for nesting activities.</p>

<p class="">Consider the following <code class="text-purple">Logger</code> activity.</p>

<pre class=""><code class="rounded">class Logger &lt; Trailblazer::Activity::Railway
  step :log

  def log(ctx, logged:, **)
    ctx[:log] = logged.inspect
  end
end
</code></pre>

<p class="">Along with the nested <code class="text-purple">Logger</code> step should also go <code class="text-purple">:input</code> and <code class="text-purple">:output</code> configuration. When using the <code class="text-purple">Logger</code> in multiple operation, you would need to repeat the options, so why not pack the entire configuration in a macro?</p>

<pre class=""><code class="rounded">module Macro
  def self.Logger(logged_name: )
    {
      id: "logger",
      input:  {logged_name =&gt; :logged},
      output: [:log],
      **Trailblazer::Activity::Railway.Subprocess(Logger), # nest
    }
  end
end
</code></pre>

<p class="">The nesting activity can now elegantly use the macro without inconvenient options.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step Macro::Logger(logged_name: :model) # we want to log {ctx[:model]}
end
</code></pre>

<h2 id="operation-taskwrap" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">TaskWrap</span></h2>

<p class="">The <em>taskWrap</em> is the “<code class="text-purple">around_filter</code>” of Trailblazer. It allows adding steps before and after actual tasks without having to change the activity, and without having to introduce <code class="text-purple">if</code>s.</p>

<p class="">Some prominent examples for taskWrap usage in the wild are <a href="https://github.com/trailblazer/trailblazer-activity-dsl-linear/blob/f54ce384f57dde063f77a769487fc38023217910/lib/trailblazer/activity/dsl/linear/variable_mapping.rb" class="underline text-purple">variable mapping</a> and tracing happening in <a href="https://github.com/trailblazer/trailblazer-developer/blob/de84d67ac390fee5e98ffc0a172cf80141e06c81/lib/trailblazer/developer/trace.rb" class="underline text-purple"><code class="text-purple">#wtf?</code></a>. Those are features completely separated from the core code. You can use the taskWrap mechanics to inject static wraps at compile time (as it’s done for, say, the <code class="text-purple">In()</code> feature), or at runtime, the way <code class="text-purple">#wtf?</code> is built.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/task_wrap_validate-2ca816c5a0ea2dd16997f39ca8913009e6f22a0e5ec68134f260ba378a738210.png" /></p>

<p class="">It’s possible to configure a specific taskWrap for a particular step, or run the same one for all steps encountered while running an activity, even with nesting.</p>

<h3 id="operation-taskwrap-example" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Example</span></h3>

<p class="">Let’s discuss the taskWrap with the following simple <code class="text-purple">Create</code> activity that you’ve probably met before.</p>

<pre class=""><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step :validate
    left :handle_errors
    step :notify
    # ...
  end
end
</code></pre>

<p class="">We’re using an imaginary <code class="text-purple">MyAPM</code> gem that provides a convenient interface for starting and stopping instrumentation.</p>

<pre class=""><code class="rounded">span = MyAPM.start_span("validate", payload: {time: Time.now})
# do whatever you have to...
span.finish(payload: {time: Time.now})
</code></pre>

<h3 id="operation-taskwrap-step" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Step</span></h3>

<p class="">In order to execute the instrumentation, we have to write two taskWrap steps, one to start, one for finishing the instrumentation. Those steps look similar to “ordinary” activity steps, but expose the taskWrap interface.</p>

<pre class=""><code class="rounded">module MyAPM # Advanced performance monitoring, done right!
  module Extension
    def self.start_instrumentation(wrap_ctx, original_args)
      (ctx, _flow_options), circuit_options = original_args

      activity  = circuit_options[:activity] # currently running Activity.
      task      = wrap_ctx[:task]            # the current "step".

      task_id   = Trailblazer::Activity::Introspect.Nodes(activity, task: task).id

      span      = MyAPM.start_span("operation.step", payload: {id: task_id})

      wrap_ctx[:span] = span

      return wrap_ctx, original_args
    end
  end
end
</code></pre>

<p class="">A taskWrap step receives two positional arguments, the <code class="text-purple">wrap_ctx</code> that is used to transport taskWrap-specific data across taskWrap steps, and the <code class="text-purple">original_args</code> that represent how the circuit called the currently invoked task.</p>

<p class="">Above, you can see how it’s possible to retrieve the currently invoked <code class="text-purple">task</code> and its <code class="text-purple">activity</code>.</p>

<p class="">We then store the <code class="text-purple">span</code> object in the <code class="text-purple">wrap_ctx</code> so the finishing code can close that span in the second taskWrap step <code class="text-purple">#finish_instrumentation</code>.</p>

<pre class=""><code class="rounded">module MyAPM # Advanced performance monitoring, done right!
  module Extension
    def self.finish_instrumentation(wrap_ctx, original_args)
      ctx   = original_args[0][0]
      span  = wrap_ctx[:span]

      span.finish(payload: ctx.inspect)

      return wrap_ctx, original_args
    end
  end
end
</code></pre>

<p class="">As you can see, the <code class="text-purple">span</code> object can be fetched from <code class="text-purple">wrap_ctx</code> as the second step is run somewhere after <code class="text-purple">start_instrumentation</code>.</p>

<h3 id="operation-taskwrap-call_task" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">call_task</span></h3>

<p class="">Each taskWrap has at least one element, the <code class="text-purple">call_task</code> step that calls the actual task. Sometimes this task is a method, such as <code class="text-purple">#validate</code>, sometimes a nested activity, and so on.</p>

<h3 id="operation-taskwrap-runtime" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Runtime</span></h3>

<p class="">The taskWrap can be extended at runtime, when <code class="text-purple">call</code>ing an activity. This allow for adding features to steps without having to change the actual business code.</p>

<h4 id="operation-taskwrap-runtime-extension" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Runtime
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Extension</span>

                  </h4>

<p class="">To actually run the <code class="text-purple">Song::Activity::Create</code> activity with this new taskWrap, we need to build a runtime extension.</p>

<pre class=""><code class="rounded">apm_extension = Trailblazer::Activity::TaskWrap::Extension(
  [MyAPM::Extension.method(:start_instrumentation),  id: "my_apm.start_span",  prepend: "task_wrap.call_task"],
  [MyAPM::Extension.method(:finish_instrumentation), id: "my_apm.finish_span", append: "task_wrap.call_task"],
)
</code></pre>

<p class="">You can configure where to insert the taskWrap steps using <code class="text-purple">:append</code> or <code class="text-purple">:prepend</code>.</p>

<h4 id="operation-taskwrap-runtime-invoke" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Runtime
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Invoke</span>

                  </h4>

<p class="">We’re now all set to inject that new taskWrap into the execution of our business activity. In the following example, the <code class="text-purple">my_wrap</code> hash is configured in a way that our extension is run around every task in <code class="text-purple">Create</code>, even for <code class="text-purple">Create</code> itself.</p>

<pre class=""><code class="rounded">my_wrap = Hash.new(apm_extension)

Song::Activity::Create.invoke(
  [
    # ctx:
    {
      song: {title: "Timebomb"},
      seq: []
    }
  ],
  wrap_runtime: my_wrap # runtime taskWrap extensions!
)
</code></pre>

<p class="">This will result in the same taskWrap being applied to every step of the activity execution path, and for <code class="text-purple">#validate</code>, looks like so.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/task_wrap_validate-2ca816c5a0ea2dd16997f39ca8913009e6f22a0e5ec68134f260ba378a738210.png" /></p>

<h4 id="operation-taskwrap-runtime-step-filter" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Runtime
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Step filter</span>

                  </h4>

<p class="">You don’t have to run a taskWrap extension around every step. It is possible to configure an extension only being applied to a particular step in your activity. Let’s invoke the new APM taskWrap only around <code class="text-purple">#validate</code>.</p>

<pre class=""><code class="rounded">validate_task = Trailblazer::Activity::Introspect
  .Nodes(Song::Activity::Create, id: :validate) # returns Node::Attributes
  .task                                         # and the actually executed task from the circuit.

my_wrap = {validate_task =&gt; apm_extension}
</code></pre>

<p class="">Note that <code class="text-purple">my_wrap</code> can map specific tasks to their taskWrap extension.</p>

<p class="">When running <code class="text-purple">Create</code> with the new configuration, the APM code is only called for <code class="text-purple">#validate</code>.</p>

<pre class=""><code class="rounded">Song::Activity::Create.invoke(
  [
    # ctx:
    {
      song: {title: "Timebomb"},
      seq: []
    }
  ],
  wrap_runtime: my_wrap # runtime taskWrap extensions!
)
</code></pre>

<h4 id="operation-taskwrap-runtime-top-activity" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Runtime
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Top activity</span>

                  </h4>

<p class="">It’s important to understand that even the top activity <code class="text-purple">Song::Activity::Create</code> is run using a taskWrap, so if you want to apply APM only to this particular “step”, you could do so as follows.</p>

<pre class=""><code class="rounded">my_wrap = {Song::Activity::Create =&gt; apm_extension}
</code></pre>

<h3 id="operation-taskwrap-static" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Static</span></h3>

<p class="">Instead of dynamically adding taskWrap extensions at runtime, in some cases you might want to do so when defining the activity class, at compile-time. For example, the <code class="text-purple">In()</code> and <code class="text-purple">Out()</code> filter DSL uses a static taskWrap extension to add steps around a specific task.</p>

<p class="">This can be achieved with the <code class="text-purple">WrapStatic()</code> helper.</p>

<pre class=""><code class="rounded">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :create_model
    step :validate,
      Extension() =&gt; Trailblazer::Activity::TaskWrap::Extension::WrapStatic(
        [MyAPM::Extension.method(:start_instrumentation),  id: "my_apm.start_span",  prepend: "task_wrap.call_task"],
        [MyAPM::Extension.method(:finish_instrumentation), id: "my_apm.finish_span", append: "task_wrap.call_task"],
      )
    left :handle_errors
    step :notify
    include T.def_steps(:create_model, :validate, :notify)
  end
end
</code></pre>

<p class="">Obviously, you’d introduce a macro here to hide all those specific details to the user of your extension.</p>

<p class="">When running, the APM instrumentation is run only around <code class="text-purple">#validate</code>.</p>

<pre class=""><code class="rounded">signal, (ctx, _) = Song::Activity::Create.invoke([ctx, {}])
</code></pre>

<h3 id="operation-taskwrap-introspection" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Introspection</span></h3>

<p class="">You can use our web-based debugger to introspect the static taskWrap of any step.</p>

<!-- example :if -->

<!-- Example tracing
https://gist.github.com/matheusca/893dc965bd06c97625b2cb2adae418b4#file-test-rb-L22
 -->

<h2 id="operation-internals" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Internals</span></h2>

<p class="">This section discusses low-level structures and is intended for engineers interested in changing or adding their own DSLs, the activity build process, or who want to optimize the Trailblazer internals (which is always appreciated!).</p>

<h3 id="operation-internals-introspection-api" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Introspection API</span></h3>

<p class=""><span class="flex max-w-fit max-h-7 border border-grey uppercase text-grey text-xs pt-1 pb-1 pl-2 pr-2 pr-1 ml-4 rounded">
            <svg class="fill-grey mt-[2px]" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 512 512"><!--! Font Awesome Free 6.4.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license (Commercial License) Copyright 2023 Fonticons, Inc. --><path d="M168.5 72L256 165l87.5-93h-175zM383.9 99.1L311.5 176h129L383.9 99.1zm50 124.9H256 78.1L256 420.3 433.9 224zM71.5 176h129L128.1 99.1 71.5 176zm434.3 40.1l-232 256c-4.5 5-11 7.9-17.8 7.9s-13.2-2.9-17.8-7.9l-232-256c-7.7-8.5-8.3-21.2-1.5-30.4l112-152c4.5-6.1 11.7-9.8 19.3-9.8H376c7.6 0 14.8 3.6 19.3 9.8l112 152c6.8 9.2 6.1 21.9-1.5 30.4z"></path></svg>
            <a href="https://github.com/trailblazer/trailblazer-activity/tree/v0.16.0" class="ml-1" title="This feature was introduced in trailblazer-activity v0.16.0.">trailblazer-activity 0.16.0</a>
          </span></p>

<p class="">To introspect an activity and find out about steps, IDs and configuration, use the <code class="text-purple">Introspect.Nodes()</code> function.</p>

<p class="">Consider the following activity.</p>

<div class="spacing-y-0"><div class="spacing-x-1 mb-[6px]">
            <a href="#" data-toggle="code-tab" data-type="code-tab-activity">
              <span class="font-semi-bold bg-bg-purple-1 p-2 rounded-t" data-show="code-tab-activity" data-hide="code-tab-operation" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Activity</span>
            </a>
            <a href="#" data-toggle="code-tab" data-type="code-tab-operation">
              <span class="font-semi-bold bg-[#E4E4E4] p-2 rounded-t" data-show="code-tab-operation" data-hide="code-tab-activity" data-show-color="bg-bg-purple-1" data-hide-color="bg-[#E4E4E4]">Operation</span>
            </a>
          </div><div class="code-tab-activity code-tab-content"><pre class=""><code class="rounded-tr rounded-b">module Song::Activity
  class Create &lt; Trailblazer::Activity::Railway
    step :validate
    step Subprocess(Save),
      id: :save
  end
end
</code></pre></div><div class="code-tab-operation code-tab-content hidden"><pre class=""><code class="rounded-tr rounded-b">module Song::Operation
  class Create &lt; Trailblazer::Operation
    step :validate
    step Subprocess(Save),
      id: :save
  end
end
</code></pre></div></div>

<h4 id="operation-internals-introspection-api-id" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Introspection API
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">ID</span>

                  </h4>

<p class="">You can retrieve a datastructure describing a particular task by ID.</p>

<pre class=""><code class="rounded">attrs = Trailblazer::Activity::Introspect.Nodes(Song::Activity::Create, id: :validate)
</code></pre>

<p class="">The returned <code class="text-purple">Attributes</code> object exposes <code class="text-purple">#id</code>, <code class="text-purple">#data</code> and <code class="text-purple">#task</code>.</p>

<!-- # FIXME: we need a skip-convert flag for Activity -> Operation -->
<pre class=""><code class="rounded">puts attrs.id   #=&gt; :validate
puts attrs.task #=&gt; #&lt;Trailblazer::Activity::TaskBuilder::Task user_proc=validate&gt;
puts attrs.data[:extensions] =&gt; []
</code></pre>

<h4 id="operation-internals-introspection-api-task" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Introspection API
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Task</span>

                  </h4>

<p class="">It also accepts a <code class="text-purple">:task</code> option if you need to find attributes for a step where you only know the code component, not the ID. This is, for example, used in the tracing code.</p>

<pre class=""><code class="rounded">attrs = Trailblazer::Activity::Introspect.Nodes(Song::Activity::Create, task: Song::Activity::Save)
attrs.id #=&gt; :save
</code></pre>

<p class="">The returned <code class="text-purple">Attributes</code> instance behaves identically to the above.</p>

<h4 id="operation-internals-introspection-api-data" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Introspection API
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Data</span>

                  </h4>

<p class="">Note that you can use <code class="text-purple">Attributes</code> to query <a href="/2.1/docs/internals.html#internals-dsl-introspect-data" class="underline text-purple">custom data from the DSL</a>.</p>


<!-- @activity-circuit-interface <trailblazer-activity[1.0] activity, circuit interface, low level -->

<h3 id="operation-internals-circuit-interface" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Circuit Interface</span></h3>

<p class="">Activities and all tasks (or “steps”) are required to expose a <em>circuit interface</em>. This is the low-level interface. When an activity is executed, all involved tasks are called with that very signature.</p>

<p class="">Most of the times it is hidden behind the <a href="#FIXME" class="underline text-purple">task interface</a> that you’re probably used to from your operations when using <code class="text-purple">step</code>. Under the hood, however, all callable circuit elements operate through that very interface.</p>

<p class="">The circuit interface consists of three things.</p>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">A circuit element has to expose a <code class="text-purple">call</code> method.</li>
  <li class="list-image-disc ml-10">The signature of the <code class="text-purple">call</code> method is <code class="text-purple">call((ctx, flow_options), **circuit_options)</code>.</li>
  <li class="list-image-disc ml-10">Return value of the <code class="text-purple">call</code> method is an array of format <code class="text-purple">[signal, [new_ctx, new_flow_options]]</code>.</li>
</ul>

<p class="">Do not fear those syntactical finesses unfamiliar to you, young padawan.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  def self.validate((ctx, flow_options), **_circuit_options)
    # ...
    return signal, [ctx, flow_options]
  end

  step task: method(:validate)
end
</code></pre>

<p class="">Both the <code class="text-purple">Create</code> activity itself and the <code class="text-purple">validate</code> step expose the circuit interface. Note that the <code class="text-purple">:task</code> option for <code class="text-purple">step</code> configures this element as a low-level circuit interface, or in other words, it will skip the wrapping with the task interface.</p>

<h4 id="operation-internals-circuit-interface-invocation" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Circuit Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Invocation</span>

                  </h4>

<p class="">Maybe it makes more sense now when you see how an activity is called manually? Here’s how to invoke <code class="text-purple">Create</code>.</p>

<pre class=""><code class="rounded">ctx          = {name: "Face to Face"}
flow_options = {}

signal, (ctx, _flow_options) = Create.([ctx, flow_options])

signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:success&gt;
ctx    #=&gt; {:name=&gt;\"Face to Face\", :validate_outcome=&gt;true}
</code></pre>

<p class="">Note that both <code class="text-purple">ctx</code> and <code class="text-purple">flow_options</code> can be just anything. Per convention, they respond to a hash interface, but theoretically it’s up to you how your network of activities and tasks communicates.</p>

<p class="">Check the implementation of <code class="text-purple">validate</code> to understand how you return a different signal or a changed <code class="text-purple">ctx</code>.</p>

<pre class=""><code class="rounded">def self.validate((ctx, flow_options), **_circuit_options)
  is_valid = ctx[:name].nil? ? false : true

  ctx    = ctx.merge(validate_outcome: is_valid) # you can change ctx
  signal = is_valid ? Trailblazer::Activity::Right : Trailblazer::Activity::Left

  return signal, [ctx, flow_options]
end
</code></pre>

<p class="">Make sure to always stick to the <code class="text-purple">return</code> signature on the circuit interface level.</p>

<h4 id="operation-internals-circuit-interface-signature" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Circuit Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Signature</span>

                  </h4>

<p class="">The circuit interface is a bit more clumsy but it gives you unlimited power over the way the activity will be run. And trust us, we’ve been playing with different APIs for two years and this was the easiest and fastest outcome.</p>

<pre class=""><code class="rounded">def self.validate((ctx, flow_options), **_circuit_options)
  # ...
  return signal, [ctx, flow_options]
end
</code></pre>

<p class="">The alienating signature uses <a href="https://docs.ruby-lang.org/en/2.1.0/syntax/methods_rdoc.html#label-Array+Decomposition" class="underline text-purple">Ruby’s decomposition</a> feature. This only works because the first argument for <code class="text-purple">call</code> is actually an array.</p>

<p class="">Using this interface empowers you to fully take <em>control of the flow™</em>.</p>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">You can return any <code class="text-purple">signal</code> you want, not only the binary style in <em>steps</em>. Do not forget to wire that signal appropriately to the next task, though.</li>
  <li class="list-image-disc ml-10">If needed, the <code class="text-purple">ctx</code> object might be mutated or, better, replaced and a new version returned. This is the place where you’d start implementing an immutable version of Trailblazer’s <code class="text-purple">ctx</code>, for instance.</li>
  <li class="list-image-disc ml-10">Advanced features like tracing, input/output filters or type checking leverage the framework argument <code class="text-purple">flow_options</code>, which will be passed onwards through the entire activities flow. Know what you’re doing when using <code class="text-purple">flow_options</code> and <strong>always return it</strong> even if you’re not changing it.</li>
  <li class="list-image-disc ml-10">The <code class="text-purple">circuit_options</code> is another framework argument needed to control the start task and more. It is immutable and you don’t have to return it. The same <code class="text-purple">circuit_options</code> are guaranteed to be passed to all invoked tasks within one activity.</li>
</ul>

<p class="">Since in 99% the <code class="text-purple">circuit_options</code> are irrelevant for you, it’s nicer and faster to discard them instantly.</p>

<pre><code class="ruby light code-snippet wow fadeIn">
def validate((ctx, flow_options), *)
  # ...
end
</code></pre>

<p class="">Use the lonely <code class="text-purple">*</code> squat asterisk to do so.</p>

<h4 id="operation-internals-circuit-interface-circuit-options" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Circuit Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Circuit options</span>

                  </h4>

<p class="">The last positional argument when <code class="text-purple">call</code>ing an activity or task is called <em>circuit options</em>. It’s a library-level hash that is guaranteed to be identical for all tasks of an activity. In other words, all tasks of one activity will be called with the same <code class="text-purple">circuit_options</code> hash.</p>

<p class="">The following options are available.</p>

<h4 id="operation-internals-circuit-interface-start_task" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Circuit Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Start_task</span>

                  </h4>

<p class="">You can instruct the activity where to start - it doesn’t have to be the default start event! Use the <code class="text-purple">:start_task</code> option.</p>

<p class="">Consider this activity.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  # ...
  step :create
  step :validate
  step :save
end
</code></pre>

<p class="">Inject the <code class="text-purple">:start_task</code> option via the circuit options. The value has to be the actual callable task object. You can use the [introspection API] to grab it.</p>

<pre class=""><code class="rounded">circuit_options = {
  start_task: Trailblazer::Activity::Introspect::Nodes(B::Create, id: :validate).task
}

signal, (ctx, flow_options) = B::Create.([ctx, flow_options], **circuit_options)
</code></pre>

<p class="">Starting with <code class="text-purple">:validate</code>, the <code class="text-purple">:create</code> task will be skipped and only <code class="text-purple">:validate</code> and then <code class="text-purple">:save</code> will be executed.</p>

<p class="">Note that this is a low-level option that should not be used to build “reuseable” activities. If you want different behavior for differing contexts, you should compose different activities.</p>

<h4 id="operation-internals-circuit-interface-exec_context" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Circuit Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Exec_context</span>

                  </h4>

<p class="">When using the <code class="text-purple">step :method_name</code> DSL style, the <code class="text-purple">:exec_context</code> option controls what object provides the method implementations at runtime.</p>

<p class="">Usually, <code class="text-purple">Activity#call</code> will automatically set this, but you can invoke the <code class="text-purple">circuit</code> instead, and inject your own <code class="text-purple">exec_context</code>. This allows you to have a separate structure and implementation.</p>

<p class="">The following activity is such an “empty” structure.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  step :create
  step :save
end
</code></pre>

<p class="">You may then use a class, object or module to define the implementation of your steps.</p>

<pre class=""><code class="rounded">class Create::Implementation
  def create(ctx, params:, **)
    ctx[:model] = Memo.new(params)
  end

  def save(ctx, model:, **)
    ctx[:model].save
  end
end
    end
</code></pre>

<p class="">This is really just a container of the desired step logic, with the familiar interface.</p>

<p class="">When invoking the <code class="text-purple">Create</code> activity, you need to call the <code class="text-purple">circuit</code> directly and inject the <code class="text-purple">:exec_context</code> option.</p>

<pre class=""><code class="rounded">circuit_options = {
  exec_context: C::Create::Implementation.new
}

signal, (ctx, flow_options) = C::Create.to_h[:circuit].([ctx, flow_options], **circuit_options)
</code></pre>

<p class="">While this bypasses <code class="text-purple">Activity#call</code>, it gives you a powerful tool for advanced activity design.</p>

<h4 id="operation-internals-circuit-interface-dsl" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Circuit Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">DSL</span>

                  </h4>

<p class="">When using the DSL, use the <code class="text-purple">:task</code> option if you want your added task to be called directly with the circuit interface.  This skips the <code class="text-purple">TaskBuilder::Binary</code> wrapping.</p>

<pre><code class="ruby light code-snippet wow fadeIn">
class Create &lt; Trailblazer::Activity::Railway
  # ...
  step task: method(:validate)
end
</code></pre>

<!-- @activity-circuit-interface <trailblazer-activity[1.0] activity, circuit interface, low level -->

<p class=""><a name="activity-internals-task-interface"><!-- old name/link --></a></p>
<h3 id="operation-internals-step-interface" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Step Interface</span></h3>

<p class=""><em>a.k.a. <strong>Task interface</strong></em></p>

<p class="">The convenient high-level interface for a task implementation is - surprisingly - called <em>task interface</em>. It’s the one you will be working with 95% of your time when writing task logic.</p>

<p class="">This interface comprises of two parts.</p>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">The <strong>signature</strong> receives a mutable <code class="text-purple">ctx</code> object, and an optional list of keywords, often seen as <code class="text-purple">(ctx, **)</code>.</li>
  <li class="list-image-disc ml-10">The <strong>return value</strong> can be <code class="text-purple">true</code>, <code class="text-purple">false</code>, or a subclass of <code class="text-purple">Activity::Signal</code> to dictate the control flow.</li>
</ul>

<p class="">The return value does not control what is the next task. Instead, it informs the circuit runner about its outcome, and the circuit runner will find the task executed next.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Activity::Railway
    def self.create_model(ctx, **)
      attributes = ctx[:attrs]           # read from ctx

      ctx[:model] = Memo.new(attributes) # write to ctx

      ctx[:model].save ? true : false    # return value matters
    end

    step method(:create_model)
    # ...
  end
end
</code></pre>

<p class="">Components (such as methods or callable objects) exposing the step interface always receive the <code class="text-purple">ctx</code> as the first (and only) positional argument. Keyword arguments may be used to extract variables from the <code class="text-purple">ctx</code>.</p>

<p class="">Depending on the step’s logic, you can write variables to the <code class="text-purple">ctx</code> object.</p>

<p class="">The return value can be either a subclass of <code class="text-purple">Trailblazer::Activity::Signal</code> or it will be evaluated to <code class="text-purple">true</code> or <code class="text-purple">false</code>.</p>

<h4 id="operation-internals-step-interface-keyword-arguments" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Keyword Arguments</span>

                  </h4>

<p class="">A cleaner way to access data from the <code class="text-purple">ctx</code> object is to use keyword arguments in the method signature. Trailblazer makes all <code class="text-purple">ctx</code> options available as kw args.</p>

<pre class=""><code class="rounded">def self.create_model(ctx, attrs:, **) # kw args!
  ctx[:model] = Memo.new(attrs)        # write to ctx

  ctx[:model].save ? true : false      # return value matters
end
</code></pre>

<p class="">You may use as many keyword arguments as you need - it will save you reading from <code class="text-purple">ctx</code> manually, gives you automatic presence checks, and allows defaulting, too.</p>

<!-- @activity-circuit-interface-class-method <trailblazer-activity[1.0] activity, circuit interface, low level, class method -->

<h4 id="operation-internals-step-interface-return-value" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Return Value</span>

                  </h4>

<p class="">Using the DSL, your task will usually be wrapped in a <code class="text-purple">TaskBuilder::Binary</code> object, which translates a <code class="text-purple">nil</code> and <code class="text-purple">false</code> return value to an <code class="text-purple">Activity::Left</code> signal, and all other return values to <code class="text-purple">Activity::Right</code>.</p>

<pre class=""><code class="rounded">def self.create_model(ctx, attrs:, **) # kw args!
  # ...
  ctx[:model].save ? true : false      # return value matters
end
</code></pre>

<p class="">In a Railway activity, a true value will usually result in the flow staying on the “success” path, where a falsey return value deviates to the “failure” track. However, eventually it’s the developer’s decision how to <a href="#operation-wiring-api" class="underline text-purple">wire signals to connections</a>.</p>

<h4 id="operation-internals-step-interface-return-signal" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Step Interface
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Return Signal</span>

                  </h4>

<p class="">You are not limited to true and falsey return values. Any subclass of <code class="text-purple">Activity::Signal</code> will simply be passed through without getting “translated” by the <code class="text-purple">Binary</code> wrapper. This allows to emit more than two possible states from a task.</p>

<pre class=""><code class="rounded">module Memo::Operation
  class Create &lt; Trailblazer::Activity::Railway
    DatabaseError = Class.new(Trailblazer::Activity::Signal) # subclass Signal

    def create_model(ctx, attrs:, **)
      ctx[:model] = Memo.new(attrs)

      begin
        return ctx[:model].save ? true : false  # binary return values
      rescue
        return DatabaseError                    # third return value
      end
    end
    # ...

    step :create_model,
      Output(DatabaseError, :handle_error) =&gt; Id(:handle_db_error)
    step :handle_db_error,
      magnetic_to: nil, Output(:success) =&gt; Track(:failure)
  end
end
</code></pre>

<p class="">The exemplary <code class="text-purple">DatabaseError</code> is being passed through to the routing and interpreted. It’s your job to make sure this signal is wired to a following task, track, or end (line 16).</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/activity-signal-58c2fae1f7128f84076750ef30429a5038f17feab42f76616a43e4c609177dda.png" /></p>

<p class="">Note that you don’t have to use the default binary signals at all (<code class="text-purple">Left</code> and <code class="text-purple">Right</code>).
<!-- <a href="#" class="pink">
   <i class="far fa-arrow-alt-circle-right"></i>
   <span class="medium">wiring</span>
</a>
 --></p>


<h3 id="operation-internals-path-layout" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Path Layout</span></h3>

<p class="">Most of your code will be using <code class="text-purple">Trailblazer::Operation</code>, which is nothing more than a <code class="text-purple">Activity::FastTrack</code> layout.</p>

<p class="">However, if you only need a linear layout of steps, where each step is connected to its follower, you can use the <code class="text-purple">Activity::Path</code> layout.</p>

<p class="">Per default, this activity will only expose one <code class="text-purple">success</code> terminus but you’re free to customize it using the Wiring API.</p>

<pre class=""><code class="rounded">module Memo::Activity
  class Create &lt; Trailblazer::Activity::Path
    step :validate
    step :create
    # ...
  end
end
</code></pre>

<p class="">Without any additional DSL options, this results in a straight path.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/path-dfaaf5e4a8f4749788305d5c37cf0bc205f1af5098b01a483bd8e7ff833244ae.png" /></p>

<p class="">In turn, this means that only <code class="text-purple">true</code> return values in your tasks will work. The DSL will, per default, wrap every task with the <code class="text-purple">Binary</code> interface, meaning returning <code class="text-purple">true</code> will result in <code class="text-purple">Activity::Right</code>, and false in <code class="text-purple">Activity::Left</code>. Currently, only <code class="text-purple">Right</code> signals are wired up.</p>

<h4 id="operation-internals-path-layout-output" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Path Layout
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Output</span>

                  </h4>

<p class="">You may add as many outputs to a task as you need. The DSL provides the <code class="text-purple">Output()</code> helper to do so.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create
  # ...
end
</code></pre>

<p class="">The <code class="text-purple">Path</code> strategy only maintains the <code class="text-purple">:success</code>/<code class="text-purple">Activity::Right</code> semantic/signal combination. Any other combination you need to define explicitly using <code class="text-purple">Output(signal, semantic)</code>.</p>

<h4 id="operation-internals-path-layout-end" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">Path Layout
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">End</span>

                  </h4>

<p class="">The <code class="text-purple">End()</code> helper allows creating a new end event labelled with the specified semantic.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  step :validate, Output(Trailblazer::Activity::Left, :failure) =&gt; End(:invalid)
  step :create
  # ...
end
</code></pre>

<p class="">This will result in the following circuit.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/path-end-f2bd424b412c052999d67b94f0e8ca4732534972cc3e0568bf47a4508459573d.png" /></p>

<p class="">The <code class="text-purple">validate</code> task now has a <code class="text-purple">success</code> and a <code class="text-purple">failure</code> output. Since it’s wrapped using <code class="text-purple">Binary</code> it may return <code class="text-purple">true</code> or <code class="text-purple">false</code> to dictate the used output (or <code class="text-purple">Activity::Right</code>/<code class="text-purple">Activity::Left</code> since it’s the [task interface]).</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Path
  # ...
  def validate(ctx, params:, **)
    ctx[:input] = Form.validate(params) # true/false
  end

  def create(ctx, input:, **)
    Memo.create(input)
  end
end
</code></pre>

<p class="">The activity will halt on the <code class="text-purple">:invalid</code>-labelled end if <code class="text-purple">validate</code> was falsey.</p>

<pre class=""><code class="rounded">ctx = {params: nil}
signal, (ctx, flow_options) = Memo::Create.([ctx, {}])

puts signal #=&gt; #&lt;Trailblazer::Activity::End semantic=:invalid&gt;
</code></pre>

<h3 id="operation-internals-railway-layout" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Railway layout</span></h3>

<p class="">The <code class="text-purple">Activity::Railway</code> layout is great for simple railway activities. It’s used in many places in our gems for two-track code flow where additional features such as <code class="text-purple">:fast_track</code> are not needed.</p>

<pre class=""><code class="rounded">  module Memo::Activity
    class Create &lt; Trailblazer::Activity::Railway
      step :validate
      step :save
      left :handle_errors
      step :notify
      # ...
    end
  end
</code></pre>

<p class="">It has two tracks and two termini leading to <code class="text-purple">success</code> and <code class="text-purple">failure</code>.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/memo-create-2e6c44caf7b70641b970d74ac05895e5118492bbe67322eab95868819eaff5f2.png" /></p>

<p class="">This layout is perfect for internal “mini activities” in your applications.</p>

<h3 id="operation-internals-fasttrack-layout" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">FastTrack layout</span></h3>

<p class="">Based on the <code class="text-purple">Railway</code> strategy, the <code class="text-purple">FastTrack</code> pattern allows to “short-circuit” steps and exit the circuit at particular events.</p>

<p class=""><img class="mt-12 mb-12 mx-auto" src="/assets/fast_track-aab09273049fb03d465dac4afeece09ef1caca669a21d7b448a59a631c582cda.png" /></p>

<p class="">This layout provides up to four outputs for any step.</p>

<h4 id="operation-internals-fasttrack-layout-operation" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">FastTrack layout
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Operation</span>

                  </h4>

<p class="">It’s important to understand that an <code class="text-purple">Operation</code> is really just a thin public API around <code class="text-purple">Activity::FastTrack</code>. All it adds is a more convenient <code class="text-purple">#call</code> method for public use, and the <code class="text-purple">Result</code> object. The DSL and features are identical.</p>

<p class="">Please refer to the <a href="#operation-wiring-api-fast-track" class="underline text-purple">operation docs</a> to learn how to leverage the fast-track tracks.</p>

<h4 id="operation-internals-fasttrack-layout-notes" class="font-bold text-neutral-500 lg:text-1xl text-xl py-2">FastTrack layout
                  <span class="text-purple bg-lighter-purple p-2 rounded font-medium header-text">Notes</span>

                  </h4>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">All options (<code class="text-purple">:pass_fast</code>, <code class="text-purple">:fail_fast</code> and <code class="text-purple">:fast_track</code>) may be used with <code class="text-purple">step</code>, <code class="text-purple">pass</code> or <code class="text-purple">fail</code>. If in doubt, [render the circuit].</li>
  <li class="list-image-disc ml-10"><code class="text-purple">:pass_fast</code> and <code class="text-purple">:fail_fast</code> can be used in combination.</li>
</ul>

<h3 id="operation-internals-class-dependencies" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Class Dependencies</span></h3>

<p class="">If you want to configure values or dependencies on the operation class level, use the <code class="text-purple">ClassDependencies</code> module.</p>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">The usage of this feature is not recommended. Use a dry-container instead.</p>

  </div>
</div>

<p class="">You may use the <code class="text-purple">self[]=</code> setter to add directives to the operation class.</p>

<p class="">These variables will be available within every step of the operation <em>and after</em>.</p>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Operation
  extend ClassDependencies

  # Configure some dependency on class level
  self[:validator] = AlwaysTrue

  step :validate
  step Subprocess(Insert)

  def validate(ctx, validator:, params:, **)
    validator.(params)
  end
end
</code></pre>

<p class="">Starting with the invocation of the <code class="text-purple">Create</code> operation, the <code class="text-purple">validator</code> variable is injected into the <code class="text-purple">ctx</code> and passed on.</p>

<pre class=""><code class="rounded">def validate(ctx, validator:, params:, **)
  validator.(params)
end
</code></pre>

<p class="">The variable is readable from <code class="text-purple">ctx</code> even when the operation finishes - so be careful in nested setups.</p>

<pre class=""><code class="rounded">signal, (ctx, _) = Create.([ctx, {}])

puts ctx[:validator] #=&gt; AlwaysTrue
</code></pre>

<div class="rounded flex p-4 gap-4 bg-bg-purple-1/50">
  <img src="/assets/info_icon-faf751d86d27155660995d9f129cfd3b63ce05a3a91e1acdda7d214f55bdb347.svg" />
  <div class="space-y-3">
    
<p class="">Note that variables from within a nested operation are readable in the outer operation after the nested one has been invoked.</p>

  </div>
</div>

<h2 id="operation-troubleshooting" class="text-2xl font-bold text-neutral-500 lg:text-3xl py-2 flex items-center"><span class="header-text">Troubleshooting</span></h2>

<p class="">Even though tracing and <code class="text-purple">wtf?</code> attempt to make your developer experience as smooth as possible, sometimes there are annoying issues.</p>

<h3 id="operation-troubleshooting-type-error" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Type Error</span></h3>

<p class="">It’s a common error to use a bare <code class="text-purple">Hash</code> (with string keys!) instead of a <code class="text-purple">Trailblazer::Context</code> object when running an activity. While symbolized hashes are not a problem, string keys will fail.</p>

<pre class=""><code class="rounded">ctx = {"message" =&gt; "Not gonna work!"} # bare hash.
Bla.([ctx])
</code></pre>

<p class="">The infamous <code class="text-purple">TypeError</code> means your context object can’t convert strings into symbol keys. This is required when calling your steps with keyword arguments.</p>

<pre class=""><code class="rounded">TypeError: wrong argument type String (expected Symbol)
</code></pre>

<p class="">Use <code class="text-purple">Trailblazer::Context</code> as a wrapper.</p>

<pre class=""><code class="rounded">ctx = Trailblazer::Context({"message" =&gt; "Yes, works!"})

signal, (ctx, _) = Bla.([ctx])
</code></pre>

<p class="">The <code class="text-purple">Context</code> object automatically converts string keys to symbols.</p>

<h3 id="operation-troubleshooting-wrong-circuit" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Wrong circuit</span></h3>

<p class="">When using the same task multiple times in an activity, you might end up with a wiring you’re not expecting. This is due to Trailblazer internally keying tasks by their object identity.</p>

<pre class=""><code class="rounded">class Update &lt; Trailblazer::Activity::Railway
  class CheckAttribute &lt; Trailblazer::Activity::Railway
    step :valid?
  end

  step :find_model
  step Subprocess(CheckAttribute), id: :a
  step Subprocess(CheckAttribute), id: :b # same task!
  step :save
end
</code></pre>

<p class="">When introspecting this activity, you will see that the <code class="text-purple">CheckAttribute</code> task is present only once.</p>

<p class="">You need to create a copy of the method or the class of your callable task in order to fix this and have two identical steps.</p>

<pre class=""><code class="rounded">class Update &lt; Trailblazer::Activity::Railway
  class CheckAttribute &lt; Trailblazer::Activity::Railway
    step :valid?
  end

  step :find_model
  step Subprocess(CheckAttribute), id: :a
  step Subprocess(Class.new(CheckAttribute)), id: :b # different task!
  step :save
end
</code></pre>

<h3 id="operation-troubleshooting-illegal-signal-error" class="font-bold text-neutral-500 lg:text-2xl text-xl py-2 flex items-center"><span class="header-text">Illegal Signal Error</span></h3>

<p class="">As the name suggests, the <code class="text-purple">IllegalSignalError</code> exception is raised when a step returns a signal that is not registered at <a href="/2.1/docs/activity.html#activity-internals-build-structures-compilation" class="underline text-purple">compile time</a>. The routing algorithm is not able to find a connection for the returned signal and raises an error at run-time.</p>

<p class="">Usually, you encounter this beautiful exception when using the <a href="#operation-internals-circuit-interface" class="underline text-purple">circuit interface</a> signature for a step, and returning a “wrong” signal that is not wired to an on-going next task.</p>

<p class="">Other common cases may be</p>

<ul class="space-y-2">
  <li class="list-image-disc ml-10">Steps which are not wrapped by [TaskBuilder], for example: <code class="text-purple">step task: method(:validate)</code></li>
  <li class="list-image-disc ml-10"><a href="/2.1/docs/activity.html#activity-macro-api" class="underline text-purple">User defined macros</a>.</li>
</ul>

<pre class=""><code class="rounded">class Create &lt; Trailblazer::Activity::Railway
  def self.validate((ctx, flow_options), **circuit_options)
    return :invalid_signal, [ctx, flow_options], circuit_options
  end

  step task: method(:validate)
end

ctx = {"message" =&gt; "Not gonna work!"} # bare hash.
Create.([ctx])

# IllegalSignalError: Create:
# Unrecognized Signal `:invalid_signal` returned from `Method: Create.validate`. Registered signals are,
# - Trailblazer::Activity::Left
# - Trailblazer::Activity::Right
</code></pre>

<p class="">The exception helps by displaying both the actually returned signal and the registered, wired signals for this step.</p>

        </div>

            <!-- 5.5rem is lg navbar height -->
        <div class="bg-white h-screen w-56 sticky top-[5.5rem]" id="right-toc">
          <div id="docsearch" class="flex flex-col w-[203px] pt-5"></div>

          <div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-overview">
  <h4 class="font-base font-bold leading-10 pl-2">
     Overview
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-overview-step-dsl">Step DSL</a>

    
  
    <a class="block px-2 leading-8" href="#operation-overview-railway">Railway</a>

    
  
    <a class="block px-2 leading-8" href="#operation-overview-invocation">Invocation</a>

    
  
    <a class="block px-2 leading-8" href="#operation-overview-step">Step</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-overview-step-signature">Signature</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-overview-step-state">State</a>
    
  
    <a class="block px-2 leading-8" href="#operation-overview-features">Features</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-overview-features-debugging">Debugging</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-overview-features-unlimited-wiring">Unlimited wiring</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-overview-features-variable-mapping">Variable mapping</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-overview-features-bpmn-and-state-machines">BPMN and state machines</a>
    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-mechanics">
  <h4 class="font-base font-bold leading-10 pl-2">
     Mechanics
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-mechanics-invocation">Invocation</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-invocation-call">Call</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-invocation-implicit-call">Implicit call</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-invocation-input-variables">Input variables</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-invocation-keyword-arguments">Keyword arguments</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-invocation-writing-state">Writing state</a>
    
  
    <a class="block px-2 leading-8" href="#operation-mechanics-flow-control">Flow control</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-flow-control-success">Success</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-flow-control-failure">Failure</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-flow-control-signal">Signal</a>
    
  
    <a class="block px-2 leading-8" href="#operation-mechanics-terminus">Terminus</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-terminus-semantic">Semantic</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-terminus-nesting">Nesting</a>
    
  
    <a class="block px-2 leading-8" href="#operation-mechanics-result">Result</a>

    
  
    <a class="block px-2 leading-8" href="#operation-mechanics-inheritance">Inheritance</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-inheritance-subclass">Subclass</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-mechanics-inheritance-customize">Customize</a>
    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-step-dsl">
  <h4 class="font-base font-bold leading-10 pl-2">
     Step DSL
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-step-dsl-railway">Railway</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-railway-step">Step</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-railway-left">Left</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-railway-fail">Fail</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-railway-pass">Pass</a>
    
  
    <a class="block px-2 leading-8" href="#operation-step-dsl-step">Step</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-step-instance-method">Instance method</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-step-class-method">Class method</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-step-module-method">Module method</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-step-callable">Callable</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-step-lambda">Lambda</a>
    
  
    <a class="block px-2 leading-8" href="#operation-step-dsl-sequence-options">Sequence Options</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-sequence-options-id">id</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-sequence-options-delete">Delete</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-sequence-options-before">Before</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-sequence-options-after">After</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-sequence-options-replace">Replace</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-sequence-options-inherit">Inherit</a>
    
  
    <a class="block px-2 leading-8" href="#operation-step-dsl-patching">Patching</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-patching-patch">Patch</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-step-dsl-patching-patch-option">Patch Option</a>
    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-wiring-api">
  <h4 class="font-base font-bold leading-10 pl-2">
     Wiring API
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-wiring-api-railway">Railway</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-railway-debugging">Debugging</a>
    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-output-">Output()</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-output-implicit-output">Implicit output</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-output-explicit-output">Explicit output</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-output-failure">Failure</a>
    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-end-">End()</a>

    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-terminus">Terminus</a>

    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-track-">Track()</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-track-helper">Helper</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-track-custom-track">Custom Track</a>
    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-id-">Id()</a>

    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-magnetic_to">Magnetic_to</a>

    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-path-">Path()</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-path-terminus">Terminus</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-path-failure">Failure</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-path-connect_to">Connect_to</a>
    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-subprocess">Subprocess</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-subprocess-output">Output</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-subprocess-terminus">Terminus</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-subprocess-strict">Strict</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-subprocess-fast-track">Fast-track</a>
    
  
    <a class="block px-2 leading-8" href="#operation-wiring-api-fast-track">Fast-track</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-fast-track-pass_fast">pass_fast</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-fast-track-fail_fast">fail_fast</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-wiring-api-fast-track-fast_track">fast_track</a>
    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-variable-mapping">
  <h4 class="font-base font-bold leading-10 pl-2">
     Variable Mapping
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-overview">Overview</a>

    
  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-composable-i-o">Composable I/o</a>

    
  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-in-">In()</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-in-mapping-hash">Mapping hash</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-in-limiting-array">Limiting array</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-in-callable">Callable</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-in-filter-method">Filter method</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-in-keyword-arguments">Keyword arguments</a>
    
  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-out-">Out()</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-out-limiting-array">Limiting array</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-out-mapping-hash">Mapping hash</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-out-callable">Callable</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-out-keyword-arguments">Keyword arguments</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-out-outer-context">Outer context</a>
    
  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-inject-">Inject()</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-inject-array-style">Array style</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-inject-defaulting">Defaulting</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-variable-mapping-inject-override">Override</a>
    
  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-macro">Macro</a>

    
  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-inheritance">Inheritance</a>

    
  
    <a class="block px-2 leading-8" href="#operation-variable-mapping-introspect">Introspect</a>

    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-macro-api">
  <h4 class="font-base font-bold leading-10 pl-2">
     Macro API
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-macro-api-definition">Definition</a>

    
  
    <a class="block px-2 leading-8" href="#operation-macro-api-usage">Usage</a>

    
  
    <a class="block px-2 leading-8" href="#operation-macro-api-options">Options</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-macro-api-options-subprocess">Subprocess</a>
    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-taskwrap">
  <h4 class="font-base font-bold leading-10 pl-2">
     TaskWrap
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-taskwrap-example">Example</a>

    
  
    <a class="block px-2 leading-8" href="#operation-taskwrap-step">Step</a>

    
  
    <a class="block px-2 leading-8" href="#operation-taskwrap-call_task">call_task</a>

    
  
    <a class="block px-2 leading-8" href="#operation-taskwrap-runtime">Runtime</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-taskwrap-runtime-extension">Extension</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-taskwrap-runtime-invoke">Invoke</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-taskwrap-runtime-step-filter">Step filter</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-taskwrap-runtime-top-activity">Top activity</a>
    
  
    <a class="block px-2 leading-8" href="#operation-taskwrap-static">Static</a>

    
  
    <a class="block px-2 leading-8" href="#operation-taskwrap-introspection">Introspection</a>

    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-internals">
  <h4 class="font-base font-bold leading-10 pl-2">
     Internals
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-internals-introspection-api">Introspection API</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-introspection-api-id">ID</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-introspection-api-task">Task</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-introspection-api-data">Data</a>
    
  
    <a class="block px-2 leading-8" href="#operation-internals-circuit-interface">Circuit Interface</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-circuit-interface-invocation">Invocation</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-circuit-interface-signature">Signature</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-circuit-interface-circuit-options">Circuit options</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-circuit-interface-start_task">Start_task</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-circuit-interface-exec_context">Exec_context</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-circuit-interface-dsl">DSL</a>
    
  
    <a class="block px-2 leading-8" href="#operation-internals-step-interface">Step Interface</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-step-interface-keyword-arguments">Keyword Arguments</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-step-interface-return-value">Return Value</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-step-interface-return-signal">Return Signal</a>
    
  
    <a class="block px-2 leading-8" href="#operation-internals-path-layout">Path Layout</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-path-layout-output">Output</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-path-layout-end">End</a>
    
  
    <a class="block px-2 leading-8" href="#operation-internals-railway-layout">Railway layout</a>

    
  
    <a class="block px-2 leading-8" href="#operation-internals-fasttrack-layout">FastTrack layout</a>

    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-fasttrack-layout-operation">Operation</a>
    
      <a class="block px-2 pt-[.33rem] pb-[.33rem] leading-snug text-purple pl-6" href="#operation-internals-fasttrack-layout-notes">Notes</a>
    
  
    <a class="block px-2 leading-8" href="#operation-internals-class-dependencies">Class Dependencies</a>

    
  
</div>


<div class="display_none bg-white p-5 w-56 shrink-0 text-bg-blue overflow-y-scroll top-22 toc-right-height" id="right-toc-operation-troubleshooting">
  <h4 class="font-base font-bold leading-10 pl-2">
     Troubleshooting
  </h4>

  
    <a class="block px-2 leading-8" href="#operation-troubleshooting-type-error">Type Error</a>

    
  
    <a class="block px-2 leading-8" href="#operation-troubleshooting-wrong-circuit">Wrong circuit</a>

    
  
    <a class="block px-2 leading-8" href="#operation-troubleshooting-illegal-signal-error">Illegal Signal Error</a>

    
  
</div>


        </div>
      </div>
    </div>
  </div>
</section>


<footer class="lg:text-left bg-bg-blue py-16 text-white text-center text-base">
  <div class="lg:flex justify-between w-11/12 max-w-[80rem] mx-auto">
    <div class="lg:flex lg:flex-col lg:justify-between">
      <a href="/2.1/" class="block shrink-0 w-fit mx-auto lg:mx-0" >
        <img class="w-48" src="/assets/logo_white_ruby-01c45713d0879788514c52d65ac53e92d7735b42cec0baf6e080b08f9a0fb595.svg" />
      </a>
      <div class="lg:block hidden">
        © 2023 Trailblazer GmbH

      </div>
    </div>
    <div class="lg:flex lg:gap-20 xl:gap-40">
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl" href="/2.1/docs/trailblazer/">Documentation</a>
        <a href="/2.1/docs/trailblazer/#trailblazer-learn-trailblazer-tales">Videos</a>
        <a href="/2.1/docs/trailblazer/">API</a>
        <a href="/2.1/docs/operation/">Operation</a>
      </div>
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl" href="/2.1/about/">About us</a>
        <div class="flex items-center">
          <a href="https://www.linkedin.com/company/trailblazer-gmbh/">LinkedIn</a>
          <a href="https://www.linkedin.com/company/trailblazer-gmbh/">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" class="fill-white pl-2" height="1.3em"><!--!Font Awesome Free 6.6.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.--><path d="M416 32H31.9C14.3 32 0 46.5 0 64.3v383.4C0 465.5 14.3 480 31.9 480H416c17.6 0 32-14.5 32-32.3V64.3c0-17.8-14.4-32.3-32-32.3zM135.4 416H69V202.2h66.5V416zm-33.2-243c-21.3 0-38.5-17.3-38.5-38.5S80.9 96 102.2 96c21.2 0 38.5 17.3 38.5 38.5 0 21.3-17.2 38.5-38.5 38.5zm282.1 243h-66.4V312c0-24.8-.5-56.7-34.5-56.7-34.6 0-39.9 27-39.9 54.9V416h-66.4V202.2h63.7v29.2h.9c8.9-16.8 30.6-34.5 62.9-34.5 67.2 0 79.7 44.3 79.7 101.9V416z"/></svg>
          </a>
        </div>
        <a href="https://dev.to/trailblazer">Blog</a>
        <a href="/2.1/about/">Trailblazer GmbH</a>
        <a href="/2.1/pro/">Trailblazer PRO</a>
      </div>
      <div class="lg:mt-0 flex flex-col gap-5 mt-15">
        <a class="font-bold text-xl" href="https://trailblazer.zulipchat.com">Help</a>
        <a href="https://trailblazer.zulipchat.com">Chat</a>
        <a href="http://eepurl.com/hHE3a5">Newsletter</a>
      </div>
    </div>
  </div>
  <div class="lg:hidden mt-15">
    © 2023 Trailblazer GmbH
  </div>
</footer>


  </body>
</html>
